;  ASM code generated by mikroVirtualMachine for PIC - V. 8.0.0.0
;  Date/Time: 23/08/2008 13.42.24
;  Info: http://www.mikroe.com


; ADDRESS	OPCODE	ASM
; ----------------------------------------------
$0000	$158A			BSF	PCLATH, 3
$0001	$286B			GOTO	_main
$0020	$	_exitPowerSave:
;openKeyboard.c,123 :: 		void exitPowerSave(){
;openKeyboard.c,124 :: 		INTCON.RBIE = 0; // disables PORTB on-change interrupt
$0020	$118B			BCF	INTCON, 3
;openKeyboard.c,125 :: 		}
$0021	$0008			RETURN
$0004	$	_interrupt:
$0004	$00FF			MOVWF	STACK_15
$0005	$0E03			SWAPF	STATUS, 0
$0006	$0183			CLRF	STATUS
$0007	$00D9			MOVWF	?saveSTATUS
$0008	$0804			MOVF	FSR, 0
$0009	$00D8			MOVWF	?saveFSR
$000A	$080A			MOVF	PCLATH, 0
$000B	$00DA			MOVWF	?savePCLATH
$000C	$018A			CLRF	PCLATH
$000D	$0870			MOVF	STACK_0, 0
$000E	$00E5			MOVWF	STSAVED_0
;openKeyboard.c,442 :: 		void interrupt() {
;openKeyboard.c,443 :: 		if (INTCON.RBIF) { // SOMETHING CHANGED ON PORTB...
$000F	$1C0B			BTFSS	INTCON, 0
$0010	$2813			GOTO	L_interrupt_85
;openKeyboard.c,444 :: 		exitPowerSave(); // just wakeup and so some scanning...
$0011	$2020			CALL	_exitPowerSave
;openKeyboard.c,445 :: 		INTCON.RBIF = 0; // clear intr flag
$0012	$100B			BCF	INTCON, 0
;openKeyboard.c,446 :: 		}
$0013	$	L_interrupt_85:
;openKeyboard.c,451 :: 		}
$0013	$	L_Interrupt_end:
$0013	$1303			BCF	STATUS, RP1
$0014	$1283			BCF	STATUS, RP0
$0015	$0865			MOVF	STSAVED_0, 0
$0016	$00F0			MOVWF	STACK_0
$0017	$085A			MOVF	?savePCLATH, 0
$0018	$008A			MOVWF	PCLATH
$0019	$0858			MOVF	?saveFSR, 0
$001A	$0084			MOVWF	FSR
$001B	$0E59			SWAPF	?saveSTATUS, 0
$001C	$0083			MOVWF	STATUS
$001D	$0EFF			SWAPF	STACK_15, 1
$001E	$0E7F			SWAPF	STACK_15, 0
$001F	$0009			RETFIE
$0022	$	_Mul_16x16_S:
$0022	$1303			BCF	STATUS, RP1
$0023	$1283			BCF	STATUS, RP0
$0024	$01FB			CLRF	STACK_11
$0025	$01FA			CLRF	STACK_10
$0026	$01F9			CLRF	STACK_9
$0027	$3080			MOVLW	128
$0028	$00F8			MOVWF	STACK_8
$0029	$01FD			CLRF	STACK_13
$002A	$1FF1			BTFSS	STACK_1, 7
$002B	$2832			GOTO	$+7
$002C	$09F1			COMF	STACK_1, F
$002D	$09F0			COMF	STACK_0, F
$002E	$0AF0			INCF	STACK_0, F
$002F	$1903			BTFSC	STATUS, Z
$0030	$0AF1			INCF	STACK_1, F
$0031	$0AFD			INCF	STACK_13, F
$0032	$1FF5			BTFSS	STACK_5, 7
$0033	$283A			GOTO	$+7
$0034	$09F5			COMF	STACK_5, F
$0035	$09F4			COMF	STACK_4, F
$0036	$0AF4			INCF	STACK_4, F
$0037	$1903			BTFSC	STATUS, Z
$0038	$0AF5			INCF	STACK_5, F
$0039	$0AFD			INCF	STACK_13, F
$003A	$0CF1			RRF	STACK_1, F
$003B	$0CF0			RRF	STACK_0, F
$003C	$1C03			BTFSS	STATUS, C
$003D	$2847			GOTO	$+10
$003E	$0874			MOVF	STACK_4, W
$003F	$07F9			ADDWF	STACK_9, F
$0040	$0875			MOVF	STACK_5, W
$0041	$1803			BTFSC	STATUS, C
$0042	$0F75			INCFSZ	STACK_5, W
$0043	$07FA			ADDWF	STACK_10, F
$0044	$1803			BTFSC	STATUS, C
$0045	$0AFB			INCF	STACK_11, F
$0046	$1003			BCF	STATUS, C
$0047	$1FF0			BTFSS	STACK_0, 7
$0048	$284F			GOTO	$+7
$0049	$0874			MOVF	STACK_4, W
$004A	$07FA			ADDWF	STACK_10, F
$004B	$1803			BTFSC	STATUS, C
$004C	$0AFB			INCF	STACK_11, F
$004D	$0875			MOVF	STACK_5, W
$004E	$07FB			ADDWF	STACK_11, F
$004F	$0CFB			RRF	STACK_11, F
$0050	$0CFA			RRF	STACK_10, F
$0051	$0CF9			RRF	STACK_9, F
$0052	$0CF8			RRF	STACK_8, F
$0053	$1C03			BTFSS	STATUS, C
$0054	$283A			GOTO	$-26
$0055	$1C7D			BTFSS	STACK_13, 0
$0056	$2862			GOTO	$+12
$0057	$09FB			COMF	STACK_11, F
$0058	$09FA			COMF	STACK_10, F
$0059	$09F9			COMF	STACK_9, F
$005A	$09F8			COMF	STACK_8, F
$005B	$0AF8			INCF	STACK_8, F
$005C	$1903			BTFSC	STATUS, Z
$005D	$0AF9			INCF	STACK_9, F
$005E	$1903			BTFSC	STATUS, Z
$005F	$0AFA			INCF	STACK_10, F
$0060	$1903			BTFSC	STATUS, Z
$0061	$0AFB			INCF	STACK_11, F
$0062	$087B			MOVF	STACK_11, W
$0063	$00F3			MOVWF	STACK_3
$0064	$087A			MOVF	STACK_10, W
$0065	$00F2			MOVWF	STACK_2
$0066	$0879			MOVF	STACK_9, W
$0067	$00F1			MOVWF	STACK_1
$0068	$0878			MOVF	STACK_8, W
$0069	$00F0			MOVWF	STACK_0
$006A	$0000			NOP
$006B	$0008			RETURN
$006C	$	_PWM1_Start:
$006C	$1303			BCF	STATUS, RP1
$006D	$1683			BSF	STATUS, RP0
$006E	$1107			BCF	TRISC, 2
$006F	$1283			BCF	STATUS, RP0
$0070	$1512			BSF	T2CON, 2
$0071	$300C			MOVLW	12
$0072	$0497			IORWF	CCP1CON, 1
$0073	$0008			RETURN
$0074	$	_PWM2_Start:
$0074	$1303			BCF	STATUS, RP1
$0075	$1683			BSF	STATUS, RP0
$0076	$1087			BCF	TRISC, 1
$0077	$1283			BCF	STATUS, RP0
$0078	$1512			BSF	T2CON, 2
$0079	$300C			MOVLW	12
$007A	$049D			IORWF	CCP2CON, 1
$007B	$0008			RETURN
$007C	$	_PWM1_Change_Duty:
$007C	$1303			BCF	STATUS, RP1
$007D	$1683			BSF	STATUS, RP0
$007E	$0812			MOVF	PR2, 0
$007F	$3F01			ADDLW	1
$0080	$00F0			MOVWF	STACK_0
$0081	$01F1			CLRF	STACK_0+1
$0082	$1803			BTFSC	STATUS, C
$0083	$0AF1			INCF	STACK_0+1, 1
$0084	$1283			BCF	STATUS, RP0
$0085	$0864			MOVF	FARG_PWM1_Change_Duty+0, 0
$0086	$00F4			MOVWF	STACK_4
$0087	$01F5			CLRF	STACK_4+1
$0088	$2022			CALL	_mul_16x16_s
$0089	$3006			MOVLW	6
$008A	$00F2			MOVWF	STACK_2
$008B	$0870			MOVF	STACK_0, 0
$008C	$00F4			MOVWF	STACK_4
$008D	$0871			MOVF	STACK_0+1, 0
$008E	$00F5			MOVWF	STACK_4+1
$008F	$0872			MOVF	STACK_2, 0
$0090	$	L_PWM1_Change_Duty_2:
$0090	$1903			BTFSC	STATUS, Z
$0091	$2899			GOTO	L_PWM1_Change_Duty_3
$0092	$1303			BCF	STATUS, RP1
$0093	$1283			BCF	STATUS, RP0
$0094	$0CF5			RRF	STACK_4+1, 1
$0095	$0CF4			RRF	STACK_4, 1
$0096	$13F5			BCF	STACK_4+1, 7
$0097	$3FFF			ADDLW	255
$0098	$2890			GOTO	L_PWM1_Change_Duty_2
$0099	$	L_PWM1_Change_Duty_3:
$0099	$1303			BCF	STATUS, RP1
$009A	$1283			BCF	STATUS, RP0
$009B	$0874			MOVF	STACK_4, 0
$009C	$00F0			MOVWF	STACK_0
$009D	$0DF0			RLF	STACK_0, 1
$009E	$1070			BCF	STACK_0, 0
$009F	$0DF0			RLF	STACK_0, 1
$00A0	$1070			BCF	STACK_0, 0
$00A1	$0DF0			RLF	STACK_0, 1
$00A2	$1070			BCF	STACK_0, 0
$00A3	$0DF0			RLF	STACK_0, 1
$00A4	$1070			BCF	STACK_0, 0
$00A5	$3030			MOVLW	48
$00A6	$0570			ANDWF	STACK_0, 0
$00A7	$00F3			MOVWF	STACK_3
$00A8	$0874			MOVF	STACK_4, 0
$00A9	$00F0			MOVWF	STACK_0
$00AA	$0875			MOVF	STACK_4+1, 0
$00AB	$00F1			MOVWF	STACK_0+1
$00AC	$0CF1			RRF	STACK_0+1, 1
$00AD	$0CF0			RRF	STACK_0, 1
$00AE	$13F1			BCF	STACK_0+1, 7
$00AF	$0CF1			RRF	STACK_0+1, 1
$00B0	$0CF0			RRF	STACK_0, 1
$00B1	$13F1			BCF	STACK_0+1, 7
$00B2	$0870			MOVF	STACK_0, 0
$00B3	$0095			MOVWF	CCPR1L
$00B4	$300F			MOVLW	15
$00B5	$0597			ANDWF	CCP1CON, 1
$00B6	$0873			MOVF	STACK_3, 0
$00B7	$0497			IORWF	CCP1CON, 1
$00B8	$0008			RETURN
$00B9	$	_PWM2_Change_Duty:
$00B9	$1303			BCF	STATUS, RP1
$00BA	$1683			BSF	STATUS, RP0
$00BB	$0812			MOVF	PR2, 0
$00BC	$3F01			ADDLW	1
$00BD	$00F0			MOVWF	STACK_0
$00BE	$01F1			CLRF	STACK_0+1
$00BF	$1803			BTFSC	STATUS, C
$00C0	$0AF1			INCF	STACK_0+1, 1
$00C1	$1283			BCF	STATUS, RP0
$00C2	$0864			MOVF	FARG_PWM2_Change_Duty+0, 0
$00C3	$00F4			MOVWF	STACK_4
$00C4	$01F5			CLRF	STACK_4+1
$00C5	$2022			CALL	_mul_16x16_s
$00C6	$3006			MOVLW	6
$00C7	$00F2			MOVWF	STACK_2
$00C8	$0870			MOVF	STACK_0, 0
$00C9	$00F4			MOVWF	STACK_4
$00CA	$0871			MOVF	STACK_0+1, 0
$00CB	$00F5			MOVWF	STACK_4+1
$00CC	$0872			MOVF	STACK_2, 0
$00CD	$	L_PWM2_Change_Duty_0:
$00CD	$1903			BTFSC	STATUS, Z
$00CE	$28D6			GOTO	L_PWM2_Change_Duty_1
$00CF	$1303			BCF	STATUS, RP1
$00D0	$1283			BCF	STATUS, RP0
$00D1	$0CF5			RRF	STACK_4+1, 1
$00D2	$0CF4			RRF	STACK_4, 1
$00D3	$13F5			BCF	STACK_4+1, 7
$00D4	$3FFF			ADDLW	255
$00D5	$28CD			GOTO	L_PWM2_Change_Duty_0
$00D6	$	L_PWM2_Change_Duty_1:
$00D6	$1303			BCF	STATUS, RP1
$00D7	$1283			BCF	STATUS, RP0
$00D8	$0874			MOVF	STACK_4, 0
$00D9	$00F0			MOVWF	STACK_0
$00DA	$0DF0			RLF	STACK_0, 1
$00DB	$1070			BCF	STACK_0, 0
$00DC	$0DF0			RLF	STACK_0, 1
$00DD	$1070			BCF	STACK_0, 0
$00DE	$0DF0			RLF	STACK_0, 1
$00DF	$1070			BCF	STACK_0, 0
$00E0	$0DF0			RLF	STACK_0, 1
$00E1	$1070			BCF	STACK_0, 0
$00E2	$3030			MOVLW	48
$00E3	$0570			ANDWF	STACK_0, 0
$00E4	$00F3			MOVWF	STACK_3
$00E5	$0874			MOVF	STACK_4, 0
$00E6	$00F0			MOVWF	STACK_0
$00E7	$0875			MOVF	STACK_4+1, 0
$00E8	$00F1			MOVWF	STACK_0+1
$00E9	$0CF1			RRF	STACK_0+1, 1
$00EA	$0CF0			RRF	STACK_0, 1
$00EB	$13F1			BCF	STACK_0+1, 7
$00EC	$0CF1			RRF	STACK_0+1, 1
$00ED	$0CF0			RRF	STACK_0, 1
$00EE	$13F1			BCF	STACK_0+1, 7
$00EF	$0870			MOVF	STACK_0, 0
$00F0	$009B			MOVWF	CCPR2L
$00F1	$300F			MOVLW	15
$00F2	$059D			ANDWF	CCP2CON, 1
$00F3	$0873			MOVF	STACK_3, 0
$00F4	$049D			IORWF	CCP2CON, 1
$00F5	$0008			RETURN
$00F6	$	_PWM1_Stop:
$00F6	$1303			BCF	STATUS, RP1
$00F7	$1683			BSF	STATUS, RP0
$00F8	$1507			BSF	TRISC, 2
$00F9	$1283			BCF	STATUS, RP0
$00FA	$1112			BCF	T2CON, 2
$00FB	$30F0			MOVLW	240
$00FC	$0597			ANDWF	CCP1CON, 1
$00FD	$0008			RETURN
$00FE	$	_PWM2_Stop:
$00FE	$1303			BCF	STATUS, RP1
$00FF	$1683			BSF	STATUS, RP0
$0100	$1487			BSF	TRISC, 1
$0101	$1283			BCF	STATUS, RP0
$0102	$1112			BCF	T2CON, 2
$0103	$30F0			MOVLW	240
$0104	$059D			ANDWF	CCP2CON, 1
$0105	$0008			RETURN
$0106	$	_turnBacklightOn:
;openKeyboard.c,154 :: 		void turnBacklightOn(){
;openKeyboard.c,155 :: 		timer = lightFadeOffTime;
$0106	$1303			BCF	STATUS, RP1
$0107	$1283			BCF	STATUS, RP0
$0108	$0824			MOVF	_lightFadeOffTime, 0
$0109	$00A0			MOVWF	_timer
$010A	$0825			MOVF	_lightFadeOffTime+1, 0
$010B	$00A1			MOVWF	_timer+1
$010C	$0826			MOVF	_lightFadeOffTime+2, 0
$010D	$00A2			MOVWF	_timer+2
$010E	$0827			MOVF	_lightFadeOffTime+3, 0
$010F	$00A3			MOVWF	_timer+3
;openKeyboard.c,156 :: 		if (!pwmRunning) {
$0110	$0828			MOVF	_pwmRunning, 0
$0111	$1D03			BTFSS	STATUS, Z
$0112	$2917			GOTO	L_turnBacklightOn_12
;openKeyboard.c,157 :: 		PWM1_Start();
$0113	$206C			CALL	_PWM1_Start
;openKeyboard.c,158 :: 		PWM2_Start();
$0114	$2074			CALL	_PWM2_Start
;openKeyboard.c,159 :: 		pwmRunning = 1;
$0115	$3001			MOVLW	1
$0116	$00A8			MOVWF	_pwmRunning
;openKeyboard.c,160 :: 		}
$0117	$	L_turnBacklightOn_12:
;openKeyboard.c,161 :: 		PWM1_Change_Duty(lightStrenght);
$0117	$1303			BCF	STATUS, RP1
$0118	$1283			BCF	STATUS, RP0
$0119	$0829			MOVF	_lightStrenght, 0
$011A	$00E4			MOVWF	FARG_PWM1_Change_Duty+0
$011B	$207C			CALL	_PWM1_Change_Duty
;openKeyboard.c,162 :: 		PWM2_Change_Duty(lightStrenght);
$011C	$0829			MOVF	_lightStrenght, 0
$011D	$00E4			MOVWF	FARG_PWM2_Change_Duty+0
$011E	$20B9			CALL	_PWM2_Change_Duty
;openKeyboard.c,163 :: 		}
$011F	$0008			RETURN
$0120	$	_EEprom_write:
$0120	$0000			NOP
$0121	$	L_EEprom_write_0:
$0121	$1703			BSF	STATUS, RP1
$0122	$1683			BSF	STATUS, RP0
$0123	$1C8C			BTFSS	EECON1, 1
$0124	$2927			GOTO	L_EEprom_write_1
$0125	$0000			NOP
$0126	$2921			GOTO	L_EEprom_write_0
$0127	$	L_EEprom_write_1:
$0127	$1303			BCF	STATUS, RP1
$0128	$1283			BCF	STATUS, RP0
$0129	$085F			MOVF	FARG_EEprom_write+0, 0
$012A	$1703			BSF	STATUS, RP1
$012B	$008D			MOVWF	EEADR
$012C	$1303			BCF	STATUS, RP1
$012D	$0860			MOVF	FARG_EEprom_write+1, 0
$012E	$1703			BSF	STATUS, RP1
$012F	$008C			MOVWF	EEDATA
$0130	$1683			BSF	STATUS, RP0
$0131	$138C			BCF	EECON1, 7
$0132	$150C			BSF	EECON1, 2
$0133	$138B			BCF	INTCON, 7
$0134	$3055			MOVLW	85
$0135	$008D			MOVWF	EECON2
$0136	$30AA			MOVLW	170
$0137	$008D			MOVWF	EECON2
$0138	$148C			BSF	EECON1, 1
$0139	$178B			BSF	INTCON, 7
$013A	$110C			BCF	EECON1, 2
$013B	$0008			RETURN
$013C	$	_PWM1_Init:
$013C	$1303			BCF	STATUS, RP1
$013D	$1283			BCF	STATUS, RP0
$013E	$0195			CLRF	CCPR1L, 1
$013F	$1217			BCF	CCP1CON, 4
$0140	$1297			BCF	CCP1CON, 5
$0141	$0008			RETURN
$0142	$	_PWM2_Init:
$0142	$1303			BCF	STATUS, RP1
$0143	$1283			BCF	STATUS, RP0
$0144	$019B			CLRF	CCPR2L, 1
$0145	$121D			BCF	CCP2CON, 4
$0146	$129D			BCF	CCP2CON, 5
$0147	$0008			RETURN
$0148	$	_Usart_Init:
$0148	$1303			BCF	STATUS, RP1
$0149	$1683			BSF	STATUS, RP0
$014A	$1698			BSF	TXSTA, 5
$014B	$3090			MOVLW	144
$014C	$1283			BCF	STATUS, RP0
$014D	$0098			MOVWF	RCSTA
$014E	$1683			BSF	STATUS, RP0
$014F	$1787			BSF	TRISC, 7
$0150	$1307			BCF	TRISC, 6
$0151	$	L_Usart_Init_0:
$0151	$1303			BCF	STATUS, RP1
$0152	$1283			BCF	STATUS, RP0
$0153	$1E8C			BTFSS	PIR1, 5
$0154	$2958			GOTO	L_Usart_Init_1
$0155	$081A			MOVF	RCREG, 0
$0156	$00E3			MOVWF	Usart_Init_tmp_L0
$0157	$2951			GOTO	L_Usart_Init_0
$0158	$	L_Usart_Init_1:
$0158	$0008			RETURN
$0159	$	_setupLightMode:
;openKeyboard.c,192 :: 		void setupLightMode(unsigned char lm){
;openKeyboard.c,194 :: 		if (pwmRunning){
$0159	$1303			BCF	STATUS, RP1
$015A	$1283			BCF	STATUS, RP0
$015B	$0828			MOVF	_pwmRunning, 0
$015C	$1903			BTFSC	STATUS, Z
$015D	$2960			GOTO	L_setupLightMode_17
;openKeyboard.c,195 :: 		PWM1_Stop();
$015E	$20F6			CALL	_PWM1_Stop
;openKeyboard.c,196 :: 		PWM2_Stop();
$015F	$20FE			CALL	_PWM2_Stop
;openKeyboard.c,197 :: 		}
$0160	$	L_setupLightMode_17:
;openKeyboard.c,199 :: 		switch (lm){
$0160	$299D			GOTO	L_setupLightMode_18
;openKeyboard.c,200 :: 		case LIGHTMODE_ALWAYSOFF: lightHandler = &nop;
$0161	$	L_setupLightMode_20:
$0161	$307D			MOVLW	#_nop
$0162	$1303			BCF	STATUS, RP1
$0163	$1283			BCF	STATUS, RP0
$0164	$00AA			MOVWF	_lightHandler
$0165	$3005			MOVLW	@#_nop
$0166	$00AB			MOVWF	_lightHandler+1
$0167	$3000			MOVLW	0
$0168	$00AC			MOVWF	_lightHandler+2
$0169	$3000			MOVLW	0
;openKeyboard.c,201 :: 		lightStrenght = 0xFF;
$016A	$30FF			MOVLW	255
$016B	$00A9			MOVWF	_lightStrenght
;openKeyboard.c,202 :: 		lightMode = LIGHTMODE_ALWAYSOFF;
$016C	$01AD			CLRF	_lightMode, 1
;openKeyboard.c,203 :: 		break;
$016D	$29AC			GOTO	L_setupLightMode_19
;openKeyboard.c,205 :: 		case LIGHTMODE_ALWAYSON:  lightHandler = &nop;
$016E	$	L_setupLightMode_21:
$016E	$307D			MOVLW	#_nop
$016F	$1303			BCF	STATUS, RP1
$0170	$1283			BCF	STATUS, RP0
$0171	$00AA			MOVWF	_lightHandler
$0172	$3005			MOVLW	@#_nop
$0173	$00AB			MOVWF	_lightHandler+1
$0174	$3000			MOVLW	0
$0175	$00AC			MOVWF	_lightHandler+2
$0176	$3000			MOVLW	0
;openKeyboard.c,206 :: 		turnBacklightOn();
$0177	$2106			CALL	_turnBacklightOn
;openKeyboard.c,207 :: 		lightMode = LIGHTMODE_ALWAYSON;
$0178	$3001			MOVLW	1
$0179	$00AD			MOVWF	_lightMode
;openKeyboard.c,208 :: 		break;
$017A	$29AC			GOTO	L_setupLightMode_19
;openKeyboard.c,210 :: 		case LIGHTMODE_FADE:      lightHandler = &lightFade;
$017B	$	L_setupLightMode_22:
$017B	$307E			MOVLW	#_lightFade
$017C	$1303			BCF	STATUS, RP1
$017D	$1283			BCF	STATUS, RP0
$017E	$00AA			MOVWF	_lightHandler
$017F	$3005			MOVLW	@#_lightFade
$0180	$00AB			MOVWF	_lightHandler+1
$0181	$3000			MOVLW	0
$0182	$00AC			MOVWF	_lightHandler+2
$0183	$3000			MOVLW	0
;openKeyboard.c,211 :: 		turnBacklightOn();
$0184	$2106			CALL	_turnBacklightOn
;openKeyboard.c,212 :: 		lightStrenght = 0x80;   // restore middle luminosity
$0185	$3080			MOVLW	128
$0186	$00A9			MOVWF	_lightStrenght
;openKeyboard.c,213 :: 		lightMode = LIGHTMODE_FADE;
$0187	$3002			MOVLW	2
$0188	$00AD			MOVWF	_lightMode
;openKeyboard.c,214 :: 		break;
$0189	$29AC			GOTO	L_setupLightMode_19
;openKeyboard.c,216 :: 		default                 : EEprom_write(CONFIG_LIGHTMODE, LIGHTMODE_ALWAYSOFF);
$018A	$	L_setupLightMode_23:
$018A	$3003			MOVLW	3
$018B	$1303			BCF	STATUS, RP1
$018C	$1283			BCF	STATUS, RP0
$018D	$00DF			MOVWF	FARG_EEprom_write+0
$018E	$01E0			CLRF	FARG_EEprom_write+1, 1
$018F	$2120			CALL	_EEprom_write
;openKeyboard.c,217 :: 		lightMode = LIGHTMODE_ALWAYSOFF;
$0190	$1303			BCF	STATUS, RP1
$0191	$1283			BCF	STATUS, RP0
$0192	$01AD			CLRF	_lightMode, 1
;openKeyboard.c,218 :: 		lightHandler = &nop;
$0193	$307D			MOVLW	#_nop
$0194	$00AA			MOVWF	_lightHandler
$0195	$3005			MOVLW	@#_nop
$0196	$00AB			MOVWF	_lightHandler+1
$0197	$3000			MOVLW	0
$0198	$00AC			MOVWF	_lightHandler+2
$0199	$3000			MOVLW	0
;openKeyboard.c,219 :: 		lightStrenght = 0xFF;
$019A	$30FF			MOVLW	255
$019B	$00A9			MOVWF	_lightStrenght
;openKeyboard.c,220 :: 		}
$019C	$29AC			GOTO	L_setupLightMode_19
$019D	$	L_setupLightMode_18:
$019D	$1303			BCF	STATUS, RP1
$019E	$1283			BCF	STATUS, RP0
$019F	$085E			MOVF	FARG_setupLightMode+0, 0
$01A0	$3A00			XORLW	0
$01A1	$1903			BTFSC	STATUS, Z
$01A2	$2961			GOTO	L_setupLightMode_20
$01A3	$085E			MOVF	FARG_setupLightMode+0, 0
$01A4	$3A01			XORLW	1
$01A5	$1903			BTFSC	STATUS, Z
$01A6	$296E			GOTO	L_setupLightMode_21
$01A7	$085E			MOVF	FARG_setupLightMode+0, 0
$01A8	$3A02			XORLW	2
$01A9	$1903			BTFSC	STATUS, Z
$01AA	$297B			GOTO	L_setupLightMode_22
$01AB	$298A			GOTO	L_setupLightMode_23
$01AC	$	L_setupLightMode_19:
;openKeyboard.c,222 :: 		PORTC = 255;
$01AC	$30FF			MOVLW	255
$01AD	$1303			BCF	STATUS, RP1
$01AE	$1283			BCF	STATUS, RP0
$01AF	$0087			MOVWF	PORTC
;openKeyboard.c,225 :: 		if (lightMode != LIGHTMODE_ALWAYSOFF) {
$01B0	$082D			MOVF	_lightMode, 0
$01B1	$3A00			XORLW	0
$01B2	$1903			BTFSC	STATUS, Z
$01B3	$29C6			GOTO	L_setupLightMode_24
;openKeyboard.c,226 :: 		PWM1_Init(40000);
$01B4	$3018			MOVLW	24
$01B5	$1683			BSF	STATUS, RP0
$01B6	$0092			MOVWF	PR2
$01B7	$213C			CALL	_PWM1_Init
;openKeyboard.c,227 :: 		PWM1_Change_Duty(lightStrenght);
$01B8	$0829			MOVF	_lightStrenght, 0
$01B9	$00E4			MOVWF	FARG_PWM1_Change_Duty+0
$01BA	$207C			CALL	_PWM1_Change_Duty
;openKeyboard.c,228 :: 		PWM1_Start();
$01BB	$206C			CALL	_PWM1_Start
;openKeyboard.c,230 :: 		PWM2_Init(40000);
$01BC	$3018			MOVLW	24
$01BD	$1683			BSF	STATUS, RP0
$01BE	$0092			MOVWF	PR2
$01BF	$2142			CALL	_PWM2_Init
;openKeyboard.c,231 :: 		PWM2_Change_Duty(lightStrenght);
$01C0	$0829			MOVF	_lightStrenght, 0
$01C1	$00E4			MOVWF	FARG_PWM2_Change_Duty+0
$01C2	$20B9			CALL	_PWM2_Change_Duty
;openKeyboard.c,232 :: 		PWM2_Start();
$01C3	$2074			CALL	_PWM2_Start
;openKeyboard.c,234 :: 		pwmRunning = 1;
$01C4	$3001			MOVLW	1
$01C5	$00A8			MOVWF	_pwmRunning
;openKeyboard.c,235 :: 		}
$01C6	$	L_setupLightMode_24:
;openKeyboard.c,236 :: 		}
$01C6	$0008			RETURN
$01C7	$	_setupUsart:
;openKeyboard.c,127 :: 		void setupUsart(unsigned char br){
;openKeyboard.c,128 :: 		switch(br){  // done so, because you can't call USART_Init(variable); but only USART_Init(literal);
$01C7	$2A1A			GOTO	L_setupUsart_0
;openKeyboard.c,129 :: 		case BAUDRATE_300:    USART_Init(300);
$01C8	$	L_setupUsart_2:
$01C8	$1303			BCF	STATUS, RP1
$01C9	$1683			BSF	STATUS, RP0
$01CA	$30CF			MOVLW	207
$01CB	$1303			BCF	STATUS, RP1
$01CC	$1683			BSF	STATUS, RP0
$01CD	$0099			MOVWF	SPBRG
$01CE	$1118			BCF	TXSTA, BRGH
$01CF	$2148			CALL	_Usart_Init
;openKeyboard.c,130 :: 		break;
$01D0	$2A43			GOTO	L_setupUsart_1
;openKeyboard.c,131 :: 		case BAUDRATE_1200:   USART_Init(1200);
$01D1	$	L_setupUsart_3:
$01D1	$30CF			MOVLW	207
$01D2	$1303			BCF	STATUS, RP1
$01D3	$1683			BSF	STATUS, RP0
$01D4	$0099			MOVWF	SPBRG
$01D5	$1518			BSF	TXSTA, BRGH
$01D6	$2148			CALL	_Usart_Init
;openKeyboard.c,132 :: 		break;
$01D7	$2A43			GOTO	L_setupUsart_1
;openKeyboard.c,133 :: 		case BAUDRATE_2400:   USART_Init(2400);
$01D8	$	L_setupUsart_4:
$01D8	$3067			MOVLW	103
$01D9	$1303			BCF	STATUS, RP1
$01DA	$1683			BSF	STATUS, RP0
$01DB	$0099			MOVWF	SPBRG
$01DC	$1518			BSF	TXSTA, BRGH
$01DD	$2148			CALL	_Usart_Init
;openKeyboard.c,134 :: 		break;
$01DE	$2A43			GOTO	L_setupUsart_1
;openKeyboard.c,135 :: 		case BAUDRATE_4800:   USART_Init(4800);
$01DF	$	L_setupUsart_5:
$01DF	$3033			MOVLW	51
$01E0	$1303			BCF	STATUS, RP1
$01E1	$1683			BSF	STATUS, RP0
$01E2	$0099			MOVWF	SPBRG
$01E3	$1518			BSF	TXSTA, BRGH
$01E4	$2148			CALL	_Usart_Init
;openKeyboard.c,136 :: 		break;
$01E5	$2A43			GOTO	L_setupUsart_1
;openKeyboard.c,137 :: 		case BAUDRATE_9600:   USART_Init(9600);
$01E6	$	L_setupUsart_6:
$01E6	$3019			MOVLW	25
$01E7	$1303			BCF	STATUS, RP1
$01E8	$1683			BSF	STATUS, RP0
$01E9	$0099			MOVWF	SPBRG
$01EA	$1518			BSF	TXSTA, BRGH
$01EB	$2148			CALL	_Usart_Init
;openKeyboard.c,138 :: 		break;
$01EC	$2A43			GOTO	L_setupUsart_1
;openKeyboard.c,139 :: 		case BAUDRATE_19200:  USART_Init(19200);
$01ED	$	L_setupUsart_7:
$01ED	$300C			MOVLW	12
$01EE	$1303			BCF	STATUS, RP1
$01EF	$1683			BSF	STATUS, RP0
$01F0	$0099			MOVWF	SPBRG
$01F1	$1518			BSF	TXSTA, BRGH
$01F2	$2148			CALL	_Usart_Init
;openKeyboard.c,140 :: 		break;
$01F3	$2A43			GOTO	L_setupUsart_1
;openKeyboard.c,141 :: 		case BAUDRATE_38400:  USART_Init(38400);
$01F4	$	L_setupUsart_8:
$01F4	$3006			MOVLW	6
$01F5	$1303			BCF	STATUS, RP1
$01F6	$1683			BSF	STATUS, RP0
$01F7	$0099			MOVWF	SPBRG
$01F8	$1518			BSF	TXSTA, BRGH
$01F9	$2148			CALL	_Usart_Init
;openKeyboard.c,142 :: 		break;
$01FA	$2A43			GOTO	L_setupUsart_1
;openKeyboard.c,143 :: 		case BAUDRATE_57600:  USART_Init(57600);
$01FB	$	L_setupUsart_9:
$01FB	$3003			MOVLW	3
$01FC	$1303			BCF	STATUS, RP1
$01FD	$1683			BSF	STATUS, RP0
$01FE	$0099			MOVWF	SPBRG
$01FF	$1518			BSF	TXSTA, BRGH
$0200	$2148			CALL	_Usart_Init
;openKeyboard.c,144 :: 		break;
$0201	$2A43			GOTO	L_setupUsart_1
;openKeyboard.c,145 :: 		case BAUDRATE_115200: USART_Init(115200);
$0202	$	L_setupUsart_10:
$0202	$3001			MOVLW	1
$0203	$1303			BCF	STATUS, RP1
$0204	$1683			BSF	STATUS, RP0
$0205	$0099			MOVWF	SPBRG
$0206	$1518			BSF	TXSTA, BRGH
$0207	$2148			CALL	_Usart_Init
;openKeyboard.c,146 :: 		break;
$0208	$2A43			GOTO	L_setupUsart_1
;openKeyboard.c,147 :: 		default: EEprom_write(CONFIG_BAUDRATE, BAUDRATE_4800); // if no config found, set a default 4800
$0209	$	L_setupUsart_11:
$0209	$3001			MOVLW	1
$020A	$1303			BCF	STATUS, RP1
$020B	$1283			BCF	STATUS, RP0
$020C	$00DF			MOVWF	FARG_EEprom_write+0
$020D	$3004			MOVLW	4
$020E	$00E0			MOVWF	FARG_EEprom_write+1
$020F	$2120			CALL	_EEprom_write
;openKeyboard.c,148 :: 		br = BAUDRATE_4800;
$0210	$3004			MOVLW	4
$0211	$1303			BCF	STATUS, RP1
$0212	$1283			BCF	STATUS, RP0
$0213	$00DE			MOVWF	FARG_setupUsart+0
;openKeyboard.c,149 :: 		USART_Init(4800);
$0214	$3033			MOVLW	51
$0215	$1683			BSF	STATUS, RP0
$0216	$0099			MOVWF	SPBRG
$0217	$1518			BSF	TXSTA, BRGH
$0218	$2148			CALL	_Usart_Init
;openKeyboard.c,150 :: 		}
$0219	$2A43			GOTO	L_setupUsart_1
$021A	$	L_setupUsart_0:
$021A	$1303			BCF	STATUS, RP1
$021B	$1283			BCF	STATUS, RP0
$021C	$1303			BCF	STATUS, RP1
$021D	$1283			BCF	STATUS, RP0
$021E	$085E			MOVF	FARG_setupUsart+0, 0
$021F	$3A01			XORLW	1
$0220	$1903			BTFSC	STATUS, Z
$0221	$29C8			GOTO	L_setupUsart_2
$0222	$085E			MOVF	FARG_setupUsart+0, 0
$0223	$3A02			XORLW	2
$0224	$1903			BTFSC	STATUS, Z
$0225	$29D1			GOTO	L_setupUsart_3
$0226	$085E			MOVF	FARG_setupUsart+0, 0
$0227	$3A03			XORLW	3
$0228	$1903			BTFSC	STATUS, Z
$0229	$29D8			GOTO	L_setupUsart_4
$022A	$085E			MOVF	FARG_setupUsart+0, 0
$022B	$3A04			XORLW	4
$022C	$1903			BTFSC	STATUS, Z
$022D	$29DF			GOTO	L_setupUsart_5
$022E	$085E			MOVF	FARG_setupUsart+0, 0
$022F	$3A05			XORLW	5
$0230	$1903			BTFSC	STATUS, Z
$0231	$29E6			GOTO	L_setupUsart_6
$0232	$085E			MOVF	FARG_setupUsart+0, 0
$0233	$3A06			XORLW	6
$0234	$1903			BTFSC	STATUS, Z
$0235	$29ED			GOTO	L_setupUsart_7
$0236	$085E			MOVF	FARG_setupUsart+0, 0
$0237	$3A07			XORLW	7
$0238	$1903			BTFSC	STATUS, Z
$0239	$29F4			GOTO	L_setupUsart_8
$023A	$085E			MOVF	FARG_setupUsart+0, 0
$023B	$3A08			XORLW	8
$023C	$1903			BTFSC	STATUS, Z
$023D	$29FB			GOTO	L_setupUsart_9
$023E	$085E			MOVF	FARG_setupUsart+0, 0
$023F	$3A09			XORLW	9
$0240	$1903			BTFSC	STATUS, Z
$0241	$2A02			GOTO	L_setupUsart_10
$0242	$2A09			GOTO	L_setupUsart_11
$0243	$	L_setupUsart_1:
;openKeyboard.c,151 :: 		baudrate = br;
$0243	$1303			BCF	STATUS, RP1
$0244	$1283			BCF	STATUS, RP0
$0245	$085E			MOVF	FARG_setupUsart+0, 0
$0246	$00AE			MOVWF	_baudrate
;openKeyboard.c,152 :: 		}
$0247	$0008			RETURN
$0248	$	_setupSendMode:
;openKeyboard.c,298 :: 		void setupSendMode(unsigned char sm){
;openKeyboard.c,299 :: 		switch (sm){
$0248	$2A71			GOTO	L_setupSendMode_42
;openKeyboard.c,300 :: 		case SENDMODE_SCAN  : send = &scanSend;
$0249	$	L_setupSendMode_44:
$0249	$30C5			MOVLW	#_scanSend
$024A	$1303			BCF	STATUS, RP1
$024B	$1283			BCF	STATUS, RP0
$024C	$00AF			MOVWF	_send
$024D	$3005			MOVLW	@#_scanSend
$024E	$00B0			MOVWF	_send+1
$024F	$3000			MOVLW	0
$0250	$00B1			MOVWF	_send+2
$0251	$3000			MOVLW	0
;openKeyboard.c,301 :: 		sendMode = SENDMODE_SCAN;
$0252	$3001			MOVLW	1
$0253	$00B2			MOVWF	_sendMode
;openKeyboard.c,302 :: 		break;
$0254	$2A7E			GOTO	L_setupSendMode_43
;openKeyboard.c,304 :: 		case SENDMODE_SERIAL: send = &serialSend;
$0255	$	L_setupSendMode_45:
$0255	$3038			MOVLW	#_serialSend
$0256	$1303			BCF	STATUS, RP1
$0257	$1283			BCF	STATUS, RP0
$0258	$00AF			MOVWF	_send
$0259	$3006			MOVLW	@#_serialSend
$025A	$00B0			MOVWF	_send+1
$025B	$3000			MOVLW	0
$025C	$00B1			MOVWF	_send+2
$025D	$3000			MOVLW	0
;openKeyboard.c,305 :: 		sendMode = SENDMODE_SERIAL;
$025E	$01B2			CLRF	_sendMode, 1
;openKeyboard.c,306 :: 		break;
$025F	$2A7E			GOTO	L_setupSendMode_43
;openKeyboard.c,312 :: 		default             : send = &serialSend;
$0260	$	L_setupSendMode_46:
$0260	$3038			MOVLW	#_serialSend
$0261	$1303			BCF	STATUS, RP1
$0262	$1283			BCF	STATUS, RP0
$0263	$00AF			MOVWF	_send
$0264	$3006			MOVLW	@#_serialSend
$0265	$00B0			MOVWF	_send+1
$0266	$3000			MOVLW	0
$0267	$00B1			MOVWF	_send+2
$0268	$3000			MOVLW	0
;openKeyboard.c,313 :: 		EEprom_write(CONFIG_SENDMODE, SENDMODE_SERIAL);
$0269	$3002			MOVLW	2
$026A	$00DF			MOVWF	FARG_EEprom_write+0
$026B	$01E0			CLRF	FARG_EEprom_write+1, 1
$026C	$2120			CALL	_EEprom_write
;openKeyboard.c,314 :: 		sendMode = SENDMODE_SERIAL;
$026D	$1303			BCF	STATUS, RP1
$026E	$1283			BCF	STATUS, RP0
$026F	$01B2			CLRF	_sendMode, 1
;openKeyboard.c,315 :: 		}
$0270	$2A7E			GOTO	L_setupSendMode_43
$0271	$	L_setupSendMode_42:
$0271	$1303			BCF	STATUS, RP1
$0272	$1283			BCF	STATUS, RP0
$0273	$1303			BCF	STATUS, RP1
$0274	$1283			BCF	STATUS, RP0
$0275	$085E			MOVF	FARG_setupSendMode+0, 0
$0276	$3A01			XORLW	1
$0277	$1903			BTFSC	STATUS, Z
$0278	$2A49			GOTO	L_setupSendMode_44
$0279	$085E			MOVF	FARG_setupSendMode+0, 0
$027A	$3A00			XORLW	0
$027B	$1903			BTFSC	STATUS, Z
$027C	$2A55			GOTO	L_setupSendMode_45
$027D	$2A60			GOTO	L_setupSendMode_46
$027E	$	L_setupSendMode_43:
;openKeyboard.c,316 :: 		}
$027E	$0008			RETURN
$027F	$	_Delay_5ms:
;delays.c,39 :: 		void Delay_5ms() {
;delays.c,40 :: 		Delay_ms(5);
$027F	$3007			MOVLW	7
$0280	$1303			BCF	STATUS, RP1
$0281	$1283			BCF	STATUS, RP0
$0282	$00FB			MOVWF	STACK_11
$0283	$30FF			MOVLW	255
$0284	$00FA			MOVWF	STACK_10
$0285	$0BFB			DECFSZ	STACK_11, F
$0286	$2A88			GOTO	$+2
$0287	$2A8B			GOTO	$+4
$0288	$0BFA			DECFSZ	STACK_10, F
$0289	$2A88			GOTO	$-1
$028A	$2A85			GOTO	$-5
$028B	$3078			MOVLW	120
$028C	$00FA			MOVWF	STACK_10
$028D	$0BFA			DECFSZ	STACK_10, F
$028E	$2A8D			GOTO	$-1
$028F	$0000			NOP
$0290	$0000			NOP
;delays.c,41 :: 		}
$0291	$0008			RETURN
$0292	$	_enterPowerSave:
;openKeyboard.c,115 :: 		void enterPowerSave(){
;openKeyboard.c,116 :: 		PORTA = 0;
$0292	$1303			BCF	STATUS, RP1
$0293	$1283			BCF	STATUS, RP0
$0294	$0185			CLRF	PORTA, 1
;openKeyboard.c,117 :: 		INTCON.RBIE = 1; // enables PORTB on-change interrupt
$0295	$158B			BSF	INTCON, 3
;openKeyboard.c,119 :: 		sleep;
$0296	$0063			SLEEP
;openKeyboard.c,121 :: 		}
$0297	$0008			RETURN
$0298	$	_Usart_Write:
$0298	$	L_Usart_Write_3:
$0298	$3000			MOVLW	0
$0299	$1303			BCF	STATUS, RP1
$029A	$1683			BSF	STATUS, RP0
$029B	$1898			BTFSC	TXSTA, 1
$029C	$3001			MOVLW	1
$029D	$00F1			MOVWF	STACK_1
$029E	$0871			MOVF	STACK_1, 0
$029F	$3A00			XORLW	0
$02A0	$1D03			BTFSS	STATUS, Z
$02A1	$2AA4			GOTO	L_Usart_Write_4
$02A2	$0000			NOP
$02A3	$2A98			GOTO	L_Usart_Write_3
$02A4	$	L_Usart_Write_4:
$02A4	$1303			BCF	STATUS, RP1
$02A5	$1283			BCF	STATUS, RP0
$02A6	$085E			MOVF	FARG_Usart_Write+0, 0
$02A7	$0099			MOVWF	TXREG
$02A8	$0008			RETURN
$02A9	$	table___scanMap:
;openKeyboard.c,39 :: 		const char scanMap[50] = {      // i could output directly idx,
$02A9	$3408			RETLW	8
$02AA	$3409			RETLW	9
$02AB	$340A			RETLW	10
$02AC	$3428			RETLW	40
$02AD	$3414			RETLW	20
$02AE	$341E			RETLW	30
$02AF	$342F			RETLW	47
$02B0	$3429			RETLW	41
$02B1	$342A			RETLW	42
$02B2	$342B			RETLW	43
$02B3	$3427			RETLW	39
$02B4	$342C			RETLW	44
$02B5	$3426			RETLW	38
$02B6	$342D			RETLW	45
$02B7	$341F			RETLW	31
$02B8	$3420			RETLW	32
$02B9	$3421			RETLW	33
$02BA	$3423			RETLW	35
$02BB	$3422			RETLW	34
$02BC	$3424			RETLW	36
$02BD	$3425			RETLW	37
$02BE	$3415			RETLW	21
$02BF	$3416			RETLW	22
$02C0	$3417			RETLW	23
$02C1	$3419			RETLW	25
$02C2	$3418			RETLW	24
$02C3	$341A			RETLW	26
$02C4	$341B			RETLW	27
$02C5	$340B			RETLW	11
$02C6	$340C			RETLW	12
$02C7	$340D			RETLW	13
$02C8	$340F			RETLW	15
$02C9	$340E			RETLW	14
$02CA	$3410			RETLW	16
$02CB	$3411			RETLW	17
$02CC	$3401			RETLW	1
$02CD	$3402			RETLW	2
$02CE	$3403			RETLW	3
$02CF	$3405			RETLW	5
$02D0	$3404			RETLW	4
$02D1	$3406			RETLW	6
$02D2	$3407			RETLW	7
$02D3	$341C			RETLW	28
$02D4	$3412			RETLW	18
$02D5	$3413			RETLW	19
$02D6	$3400			RETLW	0
$02D7	$3400			RETLW	0
$02D8	$341D			RETLW	29
$02D9	$342E			RETLW	46
$02DA	$3400			RETLW	0
$02DB	$0008			RETURN
$02DC	$	_____DoICP:
$02DC	$1303			BCF	STATUS, RP1
$02DD	$1283			BCF	STATUS, RP0
$02DE	$0834			MOVF	___DoICPHiAddr, 0
$02DF	$008A			MOVWF	PCLATH
$02E0	$0835			MOVF	___DoICPLoAddr, 0
$02E1	$0082			MOVWF	PCL
$02E2	$0008			RETURN
$02E3	$	table___serialMap:
;openKeyboard.c,48 :: 		const char serialMap[4][49] = { // CHARACTER MAPPING MATRIX for "pure serial mode"
$02E3	$3438			RETLW	56
$02E4	$3439			RETLW	57
$02E5	$3430			RETLW	48
$02E6	$340D			RETLW	13
$02E7	$3470			RETLW	112
$02E8	$342C			RETLW	44
$02E9	$3400			RETLW	0
$02EA	$3400			RETLW	0
$02EB	$3400			RETLW	0
$02EC	$3400			RETLW	0
$02ED	$342E			RETLW	46
$02EE	$3420			RETLW	32
$02EF	$346D			RETLW	109
$02F0	$3400			RETLW	0
$02F1	$3400			RETLW	0
$02F2	$347A			RETLW	122
$02F3	$3478			RETLW	120
$02F4	$3476			RETLW	118
$02F5	$3463			RETLW	99
$02F6	$3462			RETLW	98
$02F7	$346E			RETLW	110
$02F8	$3461			RETLW	97
$02F9	$3473			RETLW	115
$02FA	$3464			RETLW	100
$02FB	$3467			RETLW	103
$02FC	$3466			RETLW	102
$02FD	$3468			RETLW	104
$02FE	$346A			RETLW	106
$02FF	$3471			RETLW	113
$0300	$3477			RETLW	119
$0301	$3465			RETLW	101
$0302	$3474			RETLW	116
$0303	$3472			RETLW	114
$0304	$3479			RETLW	121
$0305	$3475			RETLW	117
$0306	$3431			RETLW	49
$0307	$3432			RETLW	50
$0308	$3433			RETLW	51
$0309	$3435			RETLW	53
$030A	$3434			RETLW	52
$030B	$3436			RETLW	54
$030C	$3437			RETLW	55
$030D	$346B			RETLW	107
$030E	$3469			RETLW	105
$030F	$346F			RETLW	111
$0310	$3400			RETLW	0
$0311	$3400			RETLW	0
$0312	$346C			RETLW	108
$0313	$3408			RETLW	8
$0314	$3438			RETLW	56
$0315	$3439			RETLW	57
$0316	$3430			RETLW	48
$0317	$340D			RETLW	13
$0318	$3450			RETLW	80
$0319	$342C			RETLW	44
$031A	$3400			RETLW	0
$031B	$3400			RETLW	0
$031C	$3400			RETLW	0
$031D	$3400			RETLW	0
$031E	$342E			RETLW	46
$031F	$3420			RETLW	32
$0320	$344D			RETLW	77
$0321	$3400			RETLW	0
$0322	$3400			RETLW	0
$0323	$345A			RETLW	90
$0324	$3458			RETLW	88
$0325	$3456			RETLW	86
$0326	$3443			RETLW	67
$0327	$3442			RETLW	66
$0328	$344E			RETLW	78
$0329	$3441			RETLW	65
$032A	$3453			RETLW	83
$032B	$3444			RETLW	68
$032C	$3447			RETLW	71
$032D	$3446			RETLW	70
$032E	$3448			RETLW	72
$032F	$344A			RETLW	74
$0330	$3451			RETLW	81
$0331	$3457			RETLW	87
$0332	$3445			RETLW	69
$0333	$3454			RETLW	84
$0334	$3452			RETLW	82
$0335	$3459			RETLW	89
$0336	$3455			RETLW	85
$0337	$3431			RETLW	49
$0338	$3432			RETLW	50
$0339	$3433			RETLW	51
$033A	$3435			RETLW	53
$033B	$3434			RETLW	52
$033C	$3436			RETLW	54
$033D	$3437			RETLW	55
$033E	$344B			RETLW	75
$033F	$3449			RETLW	73
$0340	$344F			RETLW	79
$0341	$3400			RETLW	0
$0342	$3400			RETLW	0
$0343	$344C			RETLW	76
$0344	$3408			RETLW	8
$0345	$3438			RETLW	56
$0346	$3439			RETLW	57
$0347	$3430			RETLW	48
$0348	$340D			RETLW	13
$0349	$3429			RETLW	41
$034A	$343A			RETLW	58
$034B	$3400			RETLW	0
$034C	$3400			RETLW	0
$034D	$3400			RETLW	0
$034E	$3400			RETLW	0
$034F	$343F			RETLW	63
$0350	$3420			RETLW	32
$0351	$343E			RETLW	62
$0352	$3400			RETLW	0
$0353	$3400			RETLW	0
$0354	$3460			RETLW	96
$0355	$3427			RETLW	39
$0356	$342D			RETLW	45
$0357	$34BB			RETLW	187
$0358	$347C			RETLW	124
$0359	$343C			RETLW	60
$035A	$347E			RETLW	126
$035B	$349A			RETLW	154
$035C	$347B			RETLW	123
$035D	$34A8			RETLW	168
$035E	$347D			RETLW	125
$035F	$342F			RETLW	47
$0360	$3427			RETLW	39
$0361	$3421			RETLW	33
$0362	$3440			RETLW	64
$0363	$3480			RETLW	128
$0364	$3425			RETLW	37
$0365	$3423			RETLW	35
$0366	$345E			RETLW	94
$0367	$3426			RETLW	38
$0368	$3431			RETLW	49
$0369	$3432			RETLW	50
$036A	$3433			RETLW	51
$036B	$3435			RETLW	53
$036C	$3434			RETLW	52
$036D	$3436			RETLW	54
$036E	$3437			RETLW	55
$036F	$345B			RETLW	91
$0370	$342A			RETLW	42
$0371	$3428			RETLW	40
$0372	$3400			RETLW	0
$0373	$3400			RETLW	0
$0374	$345D			RETLW	93
$0375	$3408			RETLW	8
$0376	$3438			RETLW	56
$0377	$3439			RETLW	57
$0378	$3430			RETLW	48
$0379	$340D			RETLW	13
$037A	$343D			RETLW	61
$037B	$343B			RETLW	59
$037C	$3400			RETLW	0
$037D	$3400			RETLW	0
$037E	$3400			RETLW	0
$037F	$3400			RETLW	0
$0380	$34BF			RETLW	191
$0381	$3420			RETLW	32
$0382	$34B5			RETLW	181
$0383	$3400			RETLW	0
$0384	$3400			RETLW	0
$0385	$34E6			RETLW	230
$0386	$349C			RETLW	156
$0387	$345F			RETLW	95
$0388	$34E7			RETLW	231
$0389	$342B			RETLW	43
$038A	$34F1			RETLW	241
$038B	$34E1			RETLW	225
$038C	$34DF			RETLW	223
$038D	$34F0			RETLW	240
$038E	$34A5			RETLW	165
$038F	$34A3			RETLW	163
$0390	$345C			RETLW	92
$0391	$3422			RETLW	34
$0392	$34A1			RETLW	161
$0393	$34E5			RETLW	229
$0394	$34E8			RETLW	232
$0395	$34FE			RETLW	254
$0396	$3424			RETLW	36
$0397	$34FD			RETLW	253
$0398	$34F9			RETLW	249
$0399	$3431			RETLW	49
$039A	$3432			RETLW	50
$039B	$3433			RETLW	51
$039C	$3435			RETLW	53
$039D	$3434			RETLW	52
$039E	$3436			RETLW	54
$039F	$3437			RETLW	55
$03A0	$34A9			RETLW	169
$03A1	$34EC			RETLW	236
$03A2	$34F2			RETLW	242
$03A3	$3400			RETLW	0
$03A4	$3400			RETLW	0
$03A5	$34F8			RETLW	248
$03A6	$3408			RETLW	8
$03A7	$0008			RETURN
$03A8	$	_Mul_16x16_U:
$03A8	$1303			BCF	STATUS, RP1
$03A9	$1283			BCF	STATUS, RP0
$03AA	$01FB			CLRF	STACK_11
$03AB	$01FA			CLRF	STACK_10
$03AC	$01F9			CLRF	STACK_9
$03AD	$3080			MOVLW	128
$03AE	$00F8			MOVWF	STACK_8
$03AF	$0CF1			RRF	STACK_1, F
$03B0	$0CF0			RRF	STACK_0, F
$03B1	$1C03			BTFSS	STATUS, C
$03B2	$2BBC			GOTO	$+10
$03B3	$0874			MOVF	STACK_4, W
$03B4	$07F9			ADDWF	STACK_9, F
$03B5	$0875			MOVF	STACK_5, W
$03B6	$1803			BTFSC	STATUS, C
$03B7	$0F75			INCFSZ	STACK_5, W
$03B8	$07FA			ADDWF	STACK_10, F
$03B9	$1803			BTFSC	STATUS, C
$03BA	$0AFB			INCF	STACK_11, F
$03BB	$1003			BCF	STATUS, C
$03BC	$1FF0			BTFSS	STACK_0, 7
$03BD	$2BC4			GOTO	$+7
$03BE	$0874			MOVF	STACK_4, W
$03BF	$07FA			ADDWF	STACK_10, F
$03C0	$0875			MOVF	STACK_5, W
$03C1	$1803			BTFSC	STATUS, C
$03C2	$0F75			INCFSZ	STACK_5, W
$03C3	$07FB			ADDWF	STACK_11, F
$03C4	$0CFB			RRF	STACK_11, F
$03C5	$0CFA			RRF	STACK_10, F
$03C6	$0CF9			RRF	STACK_9, F
$03C7	$0CF8			RRF	STACK_8, F
$03C8	$1C03			BTFSS	STATUS, C
$03C9	$2BAF			GOTO	$-26
$03CA	$087B			MOVF	STACK_11, W
$03CB	$00F3			MOVWF	STACK_3
$03CC	$087A			MOVF	STACK_10, W
$03CD	$00F2			MOVWF	STACK_2
$03CE	$0879			MOVF	STACK_9, W
$03CF	$00F1			MOVWF	STACK_1
$03D0	$0878			MOVF	STACK_8, W
$03D1	$00F0			MOVWF	STACK_0
$03D2	$0008			RETURN
$03D3	$	_EEprom_read:
$03D3	$1303			BCF	STATUS, RP1
$03D4	$1283			BCF	STATUS, RP0
$03D5	$085B			MOVF	FARG_EEprom_read+0, 0
$03D6	$1703			BSF	STATUS, RP1
$03D7	$008D			MOVWF	EEADR
$03D8	$1683			BSF	STATUS, RP0
$03D9	$138C			BCF	EECON1, 7
$03DA	$140C			BSF	EECON1, 0
$03DB	$1283			BCF	STATUS, RP0
$03DC	$080C			MOVF	EEDATA, 0
$03DD	$00F0			MOVWF	STACK_0
$03DE	$0008			RETURN
$03DF	$	_doScan:
;openKeyboard.c,238 :: 		void doScan(){
;openKeyboard.c,239 :: 		unsigned char sc = 0;
$03DF	$1303			BCF	STATUS, RP1
$03E0	$1283			BCF	STATUS, RP0
$03E1	$01DB			CLRF	doScan_sc_L0, 1
;openKeyboard.c,241 :: 		newlyPressd = 0;
$03E2	$01B6			CLRF	_newlyPressd, 1
;openKeyboard.c,243 :: 		for (AMask=1; AMask<128; AMask<<=1){
$03E3	$3001			MOVLW	1
$03E4	$00B7			MOVWF	_AMask
$03E5	$	L_doScan_25:
$03E5	$3080			MOVLW	128
$03E6	$1303			BCF	STATUS, RP1
$03E7	$1283			BCF	STATUS, RP0
$03E8	$0237			SUBWF	_AMask, 0
$03E9	$1803			BTFSC	STATUS, C
$03EA	$2C47			GOTO	L_doScan_26
;openKeyboard.c,245 :: 		oldData[sc] = data[sc]; // save old data
$03EB	$085B			MOVF	doScan_sc_L0, 0
$03EC	$3F38			ADDLW	_oldData
$03ED	$00F1			MOVWF	STACK_1
$03EE	$085B			MOVF	doScan_sc_L0, 0
$03EF	$3F3F			ADDLW	_data
$03F0	$0084			MOVWF	FSR
$03F1	$0800			MOVF	INDF, 0
$03F2	$00F0			MOVWF	STACK_0
$03F3	$0871			MOVF	STACK_1, 0
$03F4	$0084			MOVWF	FSR
$03F5	$0870			MOVF	STACK_0, 0
$03F6	$0080			MOVWF	INDF
;openKeyboard.c,247 :: 		PORTA = ~AMask; // put a 0 on the line we want to inspect
$03F7	$0937			COMF	_AMask, W
$03F8	$0085			MOVWF	PORTA
;openKeyboard.c,248 :: 		data[sc] = PORTB;  // read PORTB (pulled up)...if a line goes to 0, bingo!
$03F9	$085B			MOVF	doScan_sc_L0, 0
$03FA	$3F3F			ADDLW	_data
$03FB	$00F0			MOVWF	STACK_0
$03FC	$0870			MOVF	STACK_0, 0
$03FD	$0084			MOVWF	FSR
$03FE	$0806			MOVF	PORTB, 0
$03FF	$0080			MOVWF	INDF
;openKeyboard.c,249 :: 		data[sc] = data[sc] | PORTB; // antibounce
$0400	$085B			MOVF	doScan_sc_L0, 0
$0401	$3F3F			ADDLW	_data
$0402	$00F1			MOVWF	STACK_1
$0403	$0871			MOVF	STACK_1, 0
$0404	$0084			MOVWF	FSR
$0405	$0800			MOVF	INDF, 0
$0406	$00F0			MOVWF	STACK_0
$0407	$0806			MOVF	PORTB, 0
$0408	$04F0			IORWF	STACK_0, 1
$0409	$0871			MOVF	STACK_1, 0
$040A	$0084			MOVWF	FSR
$040B	$0870			MOVF	STACK_0, 0
$040C	$0080			MOVWF	INDF
;openKeyboard.c,250 :: 		data[sc] = data[sc] | PORTB; // antibounce
$040D	$085B			MOVF	doScan_sc_L0, 0
$040E	$3F3F			ADDLW	_data
$040F	$00F1			MOVWF	STACK_1
$0410	$0871			MOVF	STACK_1, 0
$0411	$0084			MOVWF	FSR
$0412	$0800			MOVF	INDF, 0
$0413	$00F0			MOVWF	STACK_0
$0414	$0806			MOVF	PORTB, 0
$0415	$04F0			IORWF	STACK_0, 1
$0416	$0871			MOVF	STACK_1, 0
$0417	$0084			MOVWF	FSR
$0418	$0870			MOVF	STACK_0, 0
$0419	$0080			MOVWF	INDF
;openKeyboard.c,251 :: 		data[sc] = ~data[sc]; // return to positive logic
$041A	$085B			MOVF	doScan_sc_L0, 0
$041B	$3F3F			ADDLW	_data
$041C	$00F1			MOVWF	STACK_1
$041D	$0871			MOVF	STACK_1, 0
$041E	$0084			MOVWF	FSR
$041F	$0800			MOVF	INDF, 0
$0420	$00F0			MOVWF	STACK_0
$0421	$09F0			COMF	STACK_0, F
$0422	$0871			MOVF	STACK_1, 0
$0423	$0084			MOVWF	FSR
$0424	$0870			MOVF	STACK_0, 0
$0425	$0080			MOVWF	INDF
;openKeyboard.c,253 :: 		justPressed[sc] = data[sc]&(~oldData[sc]);
$0426	$085B			MOVF	doScan_sc_L0, 0
$0427	$3F46			ADDLW	_justPressed
$0428	$00F2			MOVWF	STACK_2
$0429	$085B			MOVF	doScan_sc_L0, 0
$042A	$3F3F			ADDLW	_data
$042B	$0084			MOVWF	FSR
$042C	$0800			MOVF	INDF, 0
$042D	$00F1			MOVWF	STACK_1
$042E	$085B			MOVF	doScan_sc_L0, 0
$042F	$3F38			ADDLW	_oldData
$0430	$0084			MOVWF	FSR
$0431	$0800			MOVF	INDF, 0
$0432	$00F0			MOVWF	STACK_0
$0433	$09F0			COMF	STACK_0, F
$0434	$0871			MOVF	STACK_1, 0
$0435	$05F0			ANDWF	STACK_0, 1
$0436	$0872			MOVF	STACK_2, 0
$0437	$0084			MOVWF	FSR
$0438	$0870			MOVF	STACK_0, 0
$0439	$0080			MOVWF	INDF
;openKeyboard.c,255 :: 		newlyPressd = newlyPressd | justPressed[sc];
$043A	$085B			MOVF	doScan_sc_L0, 0
$043B	$3F46			ADDLW	_justPressed
$043C	$0084			MOVWF	FSR
$043D	$0800			MOVF	INDF, 0
$043E	$00F0			MOVWF	STACK_0
$043F	$0870			MOVF	STACK_0, 0
$0440	$04B6			IORWF	_newlyPressd, 1
;openKeyboard.c,257 :: 		sc++;
$0441	$0ADB			INCF	doScan_sc_L0, 1
;openKeyboard.c,258 :: 		}
$0442	$	L_doScan_27:
;openKeyboard.c,243 :: 		for (AMask=1; AMask<128; AMask<<=1){
$0442	$1303			BCF	STATUS, RP1
$0443	$1283			BCF	STATUS, RP0
$0444	$0DB7			RLF	_AMask, 1
$0445	$1037			BCF	_AMask, 0
;openKeyboard.c,258 :: 		}
$0446	$2BE5			GOTO	L_doScan_25
$0447	$	L_doScan_26:
;openKeyboard.c,259 :: 		}
$0447	$0008			RETURN
$0448	$	_config:
;openKeyboard.c,318 :: 		void config(){
;openKeyboard.c,319 :: 		timer = lightFadeOffTime;
$0448	$1303			BCF	STATUS, RP1
$0449	$1283			BCF	STATUS, RP0
$044A	$0824			MOVF	_lightFadeOffTime, 0
$044B	$00A0			MOVWF	_timer
$044C	$0825			MOVF	_lightFadeOffTime+1, 0
$044D	$00A1			MOVWF	_timer+1
$044E	$0826			MOVF	_lightFadeOffTime+2, 0
$044F	$00A2			MOVWF	_timer+2
$0450	$0827			MOVF	_lightFadeOffTime+3, 0
$0451	$00A3			MOVWF	_timer+3
;openKeyboard.c,321 :: 		if ((data[1]&4)&&(lightStrenght<0xff)) {   // <
$0452	$1D40			BTFSS	_data+1, 2
$0453	$2C67			GOTO	L_config_49
$0454	$30FF			MOVLW	255
$0455	$0229			SUBWF	_lightStrenght, 0
$0456	$1803			BTFSC	STATUS, C
$0457	$2C67			GOTO	L_config_49
$0458	$	L352_ex_L_config_49:
;openKeyboard.c,322 :: 		lightStrenght++;
$0458	$1303			BCF	STATUS, RP1
$0459	$1283			BCF	STATUS, RP0
$045A	$0AA9			INCF	_lightStrenght, 1
;openKeyboard.c,323 :: 		PWM1_Change_Duty(lightStrenght);
$045B	$0829			MOVF	_lightStrenght, 0
$045C	$00E4			MOVWF	FARG_PWM1_Change_Duty+0
$045D	$207C			CALL	_PWM1_Change_Duty
;openKeyboard.c,324 :: 		PWM2_Change_Duty(lightStrenght);
$045E	$0829			MOVF	_lightStrenght, 0
$045F	$00E4			MOVWF	FARG_PWM2_Change_Duty+0
$0460	$20B9			CALL	_PWM2_Change_Duty
;openKeyboard.c,325 :: 		if (lightMode==LIGHTMODE_ALWAYSOFF) lightMode = LIGHTMODE_FADE;
$0461	$082D			MOVF	_lightMode, 0
$0462	$3A00			XORLW	0
$0463	$1D03			BTFSS	STATUS, Z
$0464	$2C67			GOTO	L_config_50
$0465	$3002			MOVLW	2
$0466	$00AD			MOVWF	_lightMode
$0467	$	L_config_50:
;openKeyboard.c,326 :: 		}  // decrease light strenght
$0467	$	L_config_49:
;openKeyboard.c,328 :: 		if ((data[1]&64)&&(lightStrenght>0)) {   // >
$0467	$1303			BCF	STATUS, RP1
$0468	$1283			BCF	STATUS, RP0
$0469	$1F40			BTFSS	_data+1, 6
$046A	$2C7E			GOTO	L_config_53
$046B	$0829			MOVF	_lightStrenght, 0
$046C	$3C00			SUBLW	0
$046D	$1803			BTFSC	STATUS, C
$046E	$2C7E			GOTO	L_config_53
$046F	$	L374_ex_L_config_53:
;openKeyboard.c,329 :: 		lightStrenght--;
$046F	$1303			BCF	STATUS, RP1
$0470	$1283			BCF	STATUS, RP0
$0471	$03A9			DECF	_lightStrenght, 1
;openKeyboard.c,330 :: 		PWM1_Change_Duty(lightStrenght);
$0472	$0829			MOVF	_lightStrenght, 0
$0473	$00E4			MOVWF	FARG_PWM1_Change_Duty+0
$0474	$207C			CALL	_PWM1_Change_Duty
;openKeyboard.c,331 :: 		PWM2_Change_Duty(lightStrenght);
$0475	$0829			MOVF	_lightStrenght, 0
$0476	$00E4			MOVWF	FARG_PWM2_Change_Duty+0
$0477	$20B9			CALL	_PWM2_Change_Duty
;openKeyboard.c,332 :: 		if (lightMode==LIGHTMODE_ALWAYSOFF) lightMode = LIGHTMODE_FADE;
$0478	$082D			MOVF	_lightMode, 0
$0479	$3A00			XORLW	0
$047A	$1D03			BTFSS	STATUS, Z
$047B	$2C7E			GOTO	L_config_54
$047C	$3002			MOVLW	2
$047D	$00AD			MOVWF	_lightMode
$047E	$	L_config_54:
;openKeyboard.c,333 :: 		} // increase light strenght
$047E	$	L_config_53:
;openKeyboard.c,336 :: 		if (justPressed[5]&1){ // 1
$047E	$3001			MOVLW	1
$047F	$1303			BCF	STATUS, RP1
$0480	$1283			BCF	STATUS, RP0
$0481	$054B			ANDWF	_justPressed+5, 0
$0482	$00F0			MOVWF	STACK_0
$0483	$1903			BTFSC	STATUS, Z
$0484	$2C8E			GOTO	L_config_55
;openKeyboard.c,340 :: 		setupLightMode(LIGHTMODE_FADE);
$0485	$3002			MOVLW	2
$0486	$00DE			MOVWF	FARG_setupLightMode+0
$0487	$2159			CALL	_setupLightMode
;openKeyboard.c,341 :: 		lightFadeOffTime = 2<<8;
$0488	$3000			MOVLW	0
$0489	$00A4			MOVWF	_lightFadeOffTime
$048A	$3002			MOVLW	2
$048B	$00A5			MOVWF	_lightFadeOffTime+1
$048C	$01A6			CLRF	_lightFadeOffTime+2
$048D	$01A7			CLRF	_lightFadeOffTime+3
;openKeyboard.c,343 :: 		}
$048E	$	L_config_55:
;openKeyboard.c,345 :: 		if (justPressed[5]&2){ // 2
$048E	$1303			BCF	STATUS, RP1
$048F	$1283			BCF	STATUS, RP0
$0490	$1CCB			BTFSS	_justPressed+5, 1
$0491	$2CA2			GOTO	L_config_56
;openKeyboard.c,346 :: 		if (data[1]&1)
$0492	$3001			MOVLW	1
$0493	$0540			ANDWF	_data+1, 0
$0494	$00F0			MOVWF	STACK_0
$0495	$1D03			BTFSS	STATUS, Z
$0496	$2CA2			GOTO	L_config_58
;openKeyboard.c,347 :: 		;//setupUsart(BAUDRATE_300);     //all setupUsart commented out are to save code words space...otherwise i'm running into demo limit
$0497	$	L_config_57:
;openKeyboard.c,349 :: 		setupLightMode(LIGHTMODE_FADE);
$0497	$3002			MOVLW	2
$0498	$1303			BCF	STATUS, RP1
$0499	$1283			BCF	STATUS, RP0
$049A	$00DE			MOVWF	FARG_setupLightMode+0
$049B	$2159			CALL	_setupLightMode
;openKeyboard.c,350 :: 		lightFadeOffTime = 4<<8;  // more or less 5 sec
$049C	$3000			MOVLW	0
$049D	$00A4			MOVWF	_lightFadeOffTime
$049E	$3004			MOVLW	4
$049F	$00A5			MOVWF	_lightFadeOffTime+1
$04A0	$01A6			CLRF	_lightFadeOffTime+2
$04A1	$01A7			CLRF	_lightFadeOffTime+3
;openKeyboard.c,351 :: 		}
$04A2	$	L_config_58:
;openKeyboard.c,352 :: 		}
$04A2	$	L_config_56:
;openKeyboard.c,354 :: 		if (justPressed[5]&4){ // 3
$04A2	$1303			BCF	STATUS, RP1
$04A3	$1283			BCF	STATUS, RP0
$04A4	$1D4B			BTFSS	_justPressed+5, 2
$04A5	$2CB6			GOTO	L_config_59
;openKeyboard.c,355 :: 		if (data[1]&1)
$04A6	$3001			MOVLW	1
$04A7	$0540			ANDWF	_data+1, 0
$04A8	$00F0			MOVWF	STACK_0
$04A9	$1D03			BTFSS	STATUS, Z
$04AA	$2CB6			GOTO	L_config_61
;openKeyboard.c,356 :: 		;//setupUsart(BAUDRATE_1200);
$04AB	$	L_config_60:
;openKeyboard.c,358 :: 		setupLightMode(LIGHTMODE_FADE);
$04AB	$3002			MOVLW	2
$04AC	$1303			BCF	STATUS, RP1
$04AD	$1283			BCF	STATUS, RP0
$04AE	$00DE			MOVWF	FARG_setupLightMode+0
$04AF	$2159			CALL	_setupLightMode
;openKeyboard.c,359 :: 		lightFadeOffTime = 8<<8;
$04B0	$3000			MOVLW	0
$04B1	$00A4			MOVWF	_lightFadeOffTime
$04B2	$3008			MOVLW	8
$04B3	$00A5			MOVWF	_lightFadeOffTime+1
$04B4	$01A6			CLRF	_lightFadeOffTime+2
$04B5	$01A7			CLRF	_lightFadeOffTime+3
;openKeyboard.c,360 :: 		}
$04B6	$	L_config_61:
;openKeyboard.c,361 :: 		}
$04B6	$	L_config_59:
;openKeyboard.c,363 :: 		if (justPressed[5]&16){ // 4
$04B6	$1303			BCF	STATUS, RP1
$04B7	$1283			BCF	STATUS, RP0
$04B8	$1E4B			BTFSS	_justPressed+5, 4
$04B9	$2CCA			GOTO	L_config_62
;openKeyboard.c,364 :: 		if (data[1]&1)
$04BA	$3001			MOVLW	1
$04BB	$0540			ANDWF	_data+1, 0
$04BC	$00F0			MOVWF	STACK_0
$04BD	$1D03			BTFSS	STATUS, Z
$04BE	$2CCA			GOTO	L_config_64
;openKeyboard.c,365 :: 		;//setupUsart(BAUDRATE_2400);
$04BF	$	L_config_63:
;openKeyboard.c,367 :: 		setupLightMode(LIGHTMODE_FADE);
$04BF	$3002			MOVLW	2
$04C0	$1303			BCF	STATUS, RP1
$04C1	$1283			BCF	STATUS, RP0
$04C2	$00DE			MOVWF	FARG_setupLightMode+0
$04C3	$2159			CALL	_setupLightMode
;openKeyboard.c,368 :: 		lightFadeOffTime = 16<<8;
$04C4	$3000			MOVLW	0
$04C5	$00A4			MOVWF	_lightFadeOffTime
$04C6	$3010			MOVLW	16
$04C7	$00A5			MOVWF	_lightFadeOffTime+1
$04C8	$01A6			CLRF	_lightFadeOffTime+2
$04C9	$01A7			CLRF	_lightFadeOffTime+3
;openKeyboard.c,369 :: 		}
$04CA	$	L_config_64:
;openKeyboard.c,370 :: 		}
$04CA	$	L_config_62:
;openKeyboard.c,372 :: 		if (justPressed[5]&8){ // 5
$04CA	$1303			BCF	STATUS, RP1
$04CB	$1283			BCF	STATUS, RP0
$04CC	$1DCB			BTFSS	_justPressed+5, 3
$04CD	$2CE2			GOTO	L_config_65
;openKeyboard.c,373 :: 		if (data[1]&1)
$04CE	$3001			MOVLW	1
$04CF	$0540			ANDWF	_data+1, 0
$04D0	$00F0			MOVWF	STACK_0
$04D1	$1903			BTFSC	STATUS, Z
$04D2	$2CD7			GOTO	L_config_66
;openKeyboard.c,374 :: 		setupUsart(BAUDRATE_4800);
$04D3	$3004			MOVLW	4
$04D4	$00DE			MOVWF	FARG_setupUsart+0
$04D5	$21C7			CALL	_setupUsart
$04D6	$2CE2			GOTO	L_config_67
$04D7	$	L_config_66:
;openKeyboard.c,376 :: 		setupLightMode(LIGHTMODE_FADE);
$04D7	$3002			MOVLW	2
$04D8	$1303			BCF	STATUS, RP1
$04D9	$1283			BCF	STATUS, RP0
$04DA	$00DE			MOVWF	FARG_setupLightMode+0
$04DB	$2159			CALL	_setupLightMode
;openKeyboard.c,377 :: 		lightFadeOffTime = 32<<8;
$04DC	$3000			MOVLW	0
$04DD	$00A4			MOVWF	_lightFadeOffTime
$04DE	$3020			MOVLW	32
$04DF	$00A5			MOVWF	_lightFadeOffTime+1
$04E0	$01A6			CLRF	_lightFadeOffTime+2
$04E1	$01A7			CLRF	_lightFadeOffTime+3
;openKeyboard.c,378 :: 		}
$04E2	$	L_config_67:
;openKeyboard.c,379 :: 		}
$04E2	$	L_config_65:
;openKeyboard.c,381 :: 		if (justPressed[5]&32){ // 6
$04E2	$1303			BCF	STATUS, RP1
$04E3	$1283			BCF	STATUS, RP0
$04E4	$1ECB			BTFSS	_justPressed+5, 5
$04E5	$2CFA			GOTO	L_config_68
;openKeyboard.c,382 :: 		if (data[1]&1)
$04E6	$3001			MOVLW	1
$04E7	$0540			ANDWF	_data+1, 0
$04E8	$00F0			MOVWF	STACK_0
$04E9	$1903			BTFSC	STATUS, Z
$04EA	$2CEF			GOTO	L_config_69
;openKeyboard.c,383 :: 		setupUsart(BAUDRATE_9600);
$04EB	$3005			MOVLW	5
$04EC	$00DE			MOVWF	FARG_setupUsart+0
$04ED	$21C7			CALL	_setupUsart
$04EE	$2CFA			GOTO	L_config_70
$04EF	$	L_config_69:
;openKeyboard.c,385 :: 		setupLightMode(LIGHTMODE_FADE);
$04EF	$3002			MOVLW	2
$04F0	$1303			BCF	STATUS, RP1
$04F1	$1283			BCF	STATUS, RP0
$04F2	$00DE			MOVWF	FARG_setupLightMode+0
$04F3	$2159			CALL	_setupLightMode
;openKeyboard.c,386 :: 		lightFadeOffTime = 64<<8;
$04F4	$3000			MOVLW	0
$04F5	$00A4			MOVWF	_lightFadeOffTime
$04F6	$3040			MOVLW	64
$04F7	$00A5			MOVWF	_lightFadeOffTime+1
$04F8	$01A6			CLRF	_lightFadeOffTime+2
$04F9	$01A7			CLRF	_lightFadeOffTime+3
;openKeyboard.c,387 :: 		}
$04FA	$	L_config_70:
;openKeyboard.c,388 :: 		}
$04FA	$	L_config_68:
;openKeyboard.c,390 :: 		if (justPressed[5]&64){ // 7
$04FA	$1303			BCF	STATUS, RP1
$04FB	$1283			BCF	STATUS, RP0
$04FC	$1F4B			BTFSS	_justPressed+5, 6
$04FD	$2D0E			GOTO	L_config_71
;openKeyboard.c,391 :: 		if (data[1]&1)
$04FE	$3001			MOVLW	1
$04FF	$0540			ANDWF	_data+1, 0
$0500	$00F0			MOVWF	STACK_0
$0501	$1D03			BTFSS	STATUS, Z
$0502	$2D0E			GOTO	L_config_73
;openKeyboard.c,392 :: 		;//setupUsart(BAUDRATE_19200);
$0503	$	L_config_72:
;openKeyboard.c,394 :: 		setupLightMode(LIGHTMODE_FADE);
$0503	$3002			MOVLW	2
$0504	$1303			BCF	STATUS, RP1
$0505	$1283			BCF	STATUS, RP0
$0506	$00DE			MOVWF	FARG_setupLightMode+0
$0507	$2159			CALL	_setupLightMode
;openKeyboard.c,395 :: 		lightFadeOffTime = 128<<8;
$0508	$3000			MOVLW	0
$0509	$00A4			MOVWF	_lightFadeOffTime
$050A	$3080			MOVLW	128
$050B	$00A5			MOVWF	_lightFadeOffTime+1
$050C	$01A6			CLRF	_lightFadeOffTime+2
$050D	$01A7			CLRF	_lightFadeOffTime+3
;openKeyboard.c,396 :: 		}
$050E	$	L_config_73:
;openKeyboard.c,397 :: 		}
$050E	$	L_config_71:
;openKeyboard.c,399 :: 		if (justPressed[0]&1){ // 8
$050E	$3001			MOVLW	1
$050F	$1303			BCF	STATUS, RP1
$0510	$1283			BCF	STATUS, RP0
$0511	$0546			ANDWF	_justPressed, 0
$0512	$00F0			MOVWF	STACK_0
$0513	$1903			BTFSC	STATUS, Z
$0514	$2D25			GOTO	L_config_74
;openKeyboard.c,400 :: 		if (data[1]&1)
$0515	$3001			MOVLW	1
$0516	$0540			ANDWF	_data+1, 0
$0517	$00F0			MOVWF	STACK_0
$0518	$1D03			BTFSS	STATUS, Z
$0519	$2D25			GOTO	L_config_76
;openKeyboard.c,401 :: 		;//setupUsart(BAUDRATE_38400);
$051A	$	L_config_75:
;openKeyboard.c,403 :: 		setupLightMode(LIGHTMODE_FADE);
$051A	$3002			MOVLW	2
$051B	$1303			BCF	STATUS, RP1
$051C	$1283			BCF	STATUS, RP0
$051D	$00DE			MOVWF	FARG_setupLightMode+0
$051E	$2159			CALL	_setupLightMode
;openKeyboard.c,404 :: 		lightFadeOffTime = 255<<8;
$051F	$3000			MOVLW	0
$0520	$00A4			MOVWF	_lightFadeOffTime
$0521	$30FF			MOVLW	255
$0522	$00A5			MOVWF	_lightFadeOffTime+1
$0523	$01A6			CLRF	_lightFadeOffTime+2
$0524	$01A7			CLRF	_lightFadeOffTime+3
;openKeyboard.c,405 :: 		}
$0525	$	L_config_76:
;openKeyboard.c,406 :: 		}
$0525	$	L_config_74:
;openKeyboard.c,408 :: 		if (justPressed[0]&2){ // 9
$0525	$1303			BCF	STATUS, RP1
$0526	$1283			BCF	STATUS, RP0
$0527	$1CC6			BTFSS	_justPressed, 1
$0528	$2D33			GOTO	L_config_77
;openKeyboard.c,409 :: 		if (data[1]&1)
$0529	$3001			MOVLW	1
$052A	$0540			ANDWF	_data+1, 0
$052B	$00F0			MOVWF	STACK_0
$052C	$1D03			BTFSS	STATUS, Z
$052D	$2D33			GOTO	L_config_79
;openKeyboard.c,410 :: 		;//setupUsart(BAUDRATE_57600);
$052E	$	L_config_78:
;openKeyboard.c,412 :: 		setupLightMode(LIGHTMODE_ALWAYSON);
$052E	$3001			MOVLW	1
$052F	$1303			BCF	STATUS, RP1
$0530	$1283			BCF	STATUS, RP0
$0531	$00DE			MOVWF	FARG_setupLightMode+0
$0532	$2159			CALL	_setupLightMode
$0533	$	L_config_79:
;openKeyboard.c,413 :: 		}
$0533	$	L_config_77:
;openKeyboard.c,415 :: 		if (justPressed[0]&4){ // 0
$0533	$1303			BCF	STATUS, RP1
$0534	$1283			BCF	STATUS, RP0
$0535	$1D46			BTFSS	_justPressed, 2
$0536	$2D40			GOTO	L_config_80
;openKeyboard.c,416 :: 		if (data[1]&1)
$0537	$3001			MOVLW	1
$0538	$0540			ANDWF	_data+1, 0
$0539	$00F0			MOVWF	STACK_0
$053A	$1D03			BTFSS	STATUS, Z
$053B	$2D40			GOTO	L_config_82
;openKeyboard.c,417 :: 		;//setupUsart(BAUDRATE_115200);
$053C	$	L_config_81:
;openKeyboard.c,419 :: 		setupLightMode(LIGHTMODE_ALWAYSOFF);
$053C	$1303			BCF	STATUS, RP1
$053D	$1283			BCF	STATUS, RP0
$053E	$01DE			CLRF	FARG_setupLightMode+0, 1
$053F	$2159			CALL	_setupLightMode
$0540	$	L_config_82:
;openKeyboard.c,420 :: 		}
$0540	$	L_config_80:
;openKeyboard.c,422 :: 		if (justPressed[3]&1){ // A
$0540	$3001			MOVLW	1
$0541	$1303			BCF	STATUS, RP1
$0542	$1283			BCF	STATUS, RP0
$0543	$0549			ANDWF	_justPressed+3, 0
$0544	$00F0			MOVWF	STACK_0
$0545	$1903			BTFSC	STATUS, Z
$0546	$2D4A			GOTO	L_config_83
;openKeyboard.c,423 :: 		setupSendMode(SENDMODE_SCAN);
$0547	$3001			MOVLW	1
$0548	$00DE			MOVWF	FARG_setupSendMode+0
$0549	$2248			CALL	_setupSendMode
;openKeyboard.c,424 :: 		}
$054A	$	L_config_83:
;openKeyboard.c,426 :: 		if (justPressed[3]&2){ // S
$054A	$1303			BCF	STATUS, RP1
$054B	$1283			BCF	STATUS, RP0
$054C	$1CC9			BTFSS	_justPressed+3, 1
$054D	$2D50			GOTO	L_config_84
;openKeyboard.c,427 :: 		setupSendMode(SENDMODE_SERIAL);
$054E	$01DE			CLRF	FARG_setupSendMode+0, 1
$054F	$2248			CALL	_setupSendMode
;openKeyboard.c,428 :: 		}
$0550	$	L_config_84:
;openKeyboard.c,430 :: 		Delay_5ms();
$0550	$227F			CALL	_Delay_5ms
;openKeyboard.c,432 :: 		}
$0551	$0008			RETURN
$0552	$	_saveConfig:
;openKeyboard.c,434 :: 		void saveConfig(){
;openKeyboard.c,435 :: 		EEprom_write(CONFIG_BAUDRATE, baudrate);
$0552	$3001			MOVLW	1
$0553	$1303			BCF	STATUS, RP1
$0554	$1283			BCF	STATUS, RP0
$0555	$00DF			MOVWF	FARG_EEprom_write+0
$0556	$082E			MOVF	_baudrate, 0
$0557	$00E0			MOVWF	FARG_EEprom_write+1
$0558	$2120			CALL	_EEprom_write
;openKeyboard.c,436 :: 		EEprom_write(CONFIG_SENDMODE, sendMode);
$0559	$3002			MOVLW	2
$055A	$1303			BCF	STATUS, RP1
$055B	$1283			BCF	STATUS, RP0
$055C	$00DF			MOVWF	FARG_EEprom_write+0
$055D	$0832			MOVF	_sendMode, 0
$055E	$00E0			MOVWF	FARG_EEprom_write+1
$055F	$2120			CALL	_EEprom_write
;openKeyboard.c,437 :: 		EEprom_write(CONFIG_LIGHTMODE, lightMode);
$0560	$3003			MOVLW	3
$0561	$1303			BCF	STATUS, RP1
$0562	$1283			BCF	STATUS, RP0
$0563	$00DF			MOVWF	FARG_EEprom_write+0
$0564	$082D			MOVF	_lightMode, 0
$0565	$00E0			MOVWF	FARG_EEprom_write+1
$0566	$2120			CALL	_EEprom_write
;openKeyboard.c,438 :: 		EEprom_write(CONFIG_LIGHTSTRENGTH, lightStrenght);
$0567	$3004			MOVLW	4
$0568	$1303			BCF	STATUS, RP1
$0569	$1283			BCF	STATUS, RP0
$056A	$00DF			MOVWF	FARG_EEprom_write+0
$056B	$0829			MOVF	_lightStrenght, 0
$056C	$00E0			MOVWF	FARG_EEprom_write+1
$056D	$2120			CALL	_EEprom_write
;openKeyboard.c,439 :: 		EEprom_write(CONFIG_LIGHTFADEOFFTIME, lightFadeOffTime>>8);
$056E	$3005			MOVLW	5
$056F	$1303			BCF	STATUS, RP1
$0570	$1283			BCF	STATUS, RP0
$0571	$00DF			MOVWF	FARG_EEprom_write+0
$0572	$0825			MOVF	_lightFadeOffTime+1, 0
$0573	$00F0			MOVWF	STACK_0
$0574	$0826			MOVF	_lightFadeOffTime+2, 0
$0575	$00F1			MOVWF	STACK_0+1
$0576	$0827			MOVF	_lightFadeOffTime+3, 0
$0577	$00F2			MOVWF	STACK_0+2
$0578	$01F3			CLRF	STACK_0+3
$0579	$0870			MOVF	STACK_0, 0
$057A	$00E0			MOVWF	FARG_EEprom_write+1
$057B	$2120			CALL	_EEprom_write
;openKeyboard.c,440 :: 		}
$057C	$0008			RETURN
$057D	$	_nop:
;openKeyboard.c,165 :: 		void nop(){
;openKeyboard.c,167 :: 		}
$057D	$0008			RETURN
$057E	$	_lightFade:
;openKeyboard.c,169 :: 		void lightFade(){
;openKeyboard.c,171 :: 		if (newlyPressd) {
$057E	$1303			BCF	STATUS, RP1
$057F	$1283			BCF	STATUS, RP0
$0580	$0836			MOVF	_newlyPressd, 0
$0581	$1903			BTFSC	STATUS, Z
$0582	$2D85			GOTO	L_lightFade_13
;openKeyboard.c,172 :: 		turnBacklightOn();
$0583	$2106			CALL	_turnBacklightOn
;openKeyboard.c,173 :: 		return;
$0584	$0008			RETURN
;openKeyboard.c,174 :: 		}
$0585	$	L_lightFade_13:
;openKeyboard.c,176 :: 		if (timer>0) timer --;
$0585	$1303			BCF	STATUS, RP1
$0586	$1283			BCF	STATUS, RP0
$0587	$0823			MOVF	_timer+3, 0
$0588	$3C00			SUBLW	0
$0589	$1D03			BTFSS	STATUS, Z
$058A	$2D95			GOTO	L_lightFade_91
$058B	$0822			MOVF	_timer+2, 0
$058C	$3C00			SUBLW	0
$058D	$1D03			BTFSS	STATUS, Z
$058E	$2D95			GOTO	L_lightFade_91
$058F	$0821			MOVF	_timer+1, 0
$0590	$3C00			SUBLW	0
$0591	$1D03			BTFSS	STATUS, Z
$0592	$2D95			GOTO	L_lightFade_91
$0593	$0820			MOVF	_timer, 0
$0594	$3C00			SUBLW	0
$0595	$	L_lightFade_91:
$0595	$1803			BTFSC	STATUS, C
$0596	$2DA2			GOTO	L_lightFade_14
$0597	$3001			MOVLW	1
$0598	$1303			BCF	STATUS, RP1
$0599	$1283			BCF	STATUS, RP0
$059A	$02A0			SUBWF	_timer, 1
$059B	$1C03			BTFSS	STATUS, C
$059C	$02A1			SUBWF	_timer+1, 1
$059D	$1C03			BTFSS	STATUS, C
$059E	$02A2			SUBWF	_timer+2, 1
$059F	$1C03			BTFSS	STATUS, C
$05A0	$02A3			SUBWF	_timer+3, 1
$05A1	$2DA8			GOTO	L_lightFade_15
$05A2	$	L_lightFade_14:
;openKeyboard.c,180 :: 		PORTC = 255;
$05A2	$30FF			MOVLW	255
$05A3	$1303			BCF	STATUS, RP1
$05A4	$1283			BCF	STATUS, RP0
$05A5	$0087			MOVWF	PORTC
;openKeyboard.c,181 :: 		pwmRunning = 0;
$05A6	$01A8			CLRF	_pwmRunning, 1
;openKeyboard.c,182 :: 		enterPowerSave();
$05A7	$2292			CALL	_enterPowerSave
;openKeyboard.c,183 :: 		}
$05A8	$	L_lightFade_15:
;openKeyboard.c,185 :: 		if (timer<(~lightStrenght)){
$05A8	$1303			BCF	STATUS, RP1
$05A9	$1283			BCF	STATUS, RP0
$05AA	$0929			COMF	_lightStrenght, W
$05AB	$00F1			MOVWF	STACK_1
$05AC	$3000			MOVLW	0
$05AD	$0223			SUBWF	_timer+3, 0
$05AE	$1D03			BTFSS	STATUS, Z
$05AF	$2DBA			GOTO	L_lightFade_92
$05B0	$3000			MOVLW	0
$05B1	$0222			SUBWF	_timer+2, 0
$05B2	$1D03			BTFSS	STATUS, Z
$05B3	$2DBA			GOTO	L_lightFade_92
$05B4	$3000			MOVLW	0
$05B5	$0221			SUBWF	_timer+1, 0
$05B6	$1D03			BTFSS	STATUS, Z
$05B7	$2DBA			GOTO	L_lightFade_92
$05B8	$0871			MOVF	STACK_1, 0
$05B9	$0220			SUBWF	_timer, 0
$05BA	$	L_lightFade_92:
$05BA	$1803			BTFSC	STATUS, C
$05BB	$2DC4			GOTO	L_lightFade_16
;openKeyboard.c,186 :: 		PWM1_Change_Duty(~((unsigned char)timer));
$05BC	$1303			BCF	STATUS, RP1
$05BD	$1283			BCF	STATUS, RP0
$05BE	$0920			COMF	_timer, W
$05BF	$00E4			MOVWF	FARG_PWM1_Change_Duty+0
$05C0	$207C			CALL	_PWM1_Change_Duty
;openKeyboard.c,187 :: 		PWM2_Change_Duty(~((unsigned char)timer));
$05C1	$0920			COMF	_timer, W
$05C2	$00E4			MOVWF	FARG_PWM2_Change_Duty+0
$05C3	$20B9			CALL	_PWM2_Change_Duty
;openKeyboard.c,188 :: 		}
$05C4	$	L_lightFade_16:
;openKeyboard.c,190 :: 		}
$05C4	$0008			RETURN
$05C5	$	_scanSend:
;openKeyboard.c,276 :: 		void scanSend(){
;openKeyboard.c,277 :: 		unsigned char idx = 0;
$05C5	$1303			BCF	STATUS, RP1
$05C6	$1283			BCF	STATUS, RP0
$05C7	$01DB			CLRF	scanSend_idx_L0, 1
;openKeyboard.c,278 :: 		unsigned char sc = 0;
$05C8	$01DC			CLRF	scanSend_sc_L0, 1
;openKeyboard.c,279 :: 		unsigned char bs = 0;
$05C9	$01DD			CLRF	scanSend_bs_L0, 1
;openKeyboard.c,281 :: 		for (AMask=1; AMask<128; AMask<<=1){
$05CA	$3001			MOVLW	1
$05CB	$00B7			MOVWF	_AMask
$05CC	$	L_scanSend_35:
$05CC	$3080			MOVLW	128
$05CD	$1303			BCF	STATUS, RP1
$05CE	$1283			BCF	STATUS, RP0
$05CF	$0237			SUBWF	_AMask, 0
$05D0	$1803			BTFSC	STATUS, C
$05D1	$2E37			GOTO	L_scanSend_36
;openKeyboard.c,282 :: 		somethingChanged = data[sc] ^ oldData[sc];
$05D2	$085C			MOVF	scanSend_sc_L0, 0
$05D3	$3F3F			ADDLW	_data
$05D4	$0084			MOVWF	FSR
$05D5	$0800			MOVF	INDF, 0
$05D6	$00CD			MOVWF	_somethingChanged
$05D7	$085C			MOVF	scanSend_sc_L0, 0
$05D8	$3F38			ADDLW	_oldData
$05D9	$0084			MOVWF	FSR
$05DA	$0800			MOVF	INDF, 0
$05DB	$00F0			MOVWF	STACK_0
$05DC	$0870			MOVF	STACK_0, 0
$05DD	$06CD			XORWF	_somethingChanged, 1
;openKeyboard.c,283 :: 		bs = 0;
$05DE	$01DD			CLRF	scanSend_bs_L0, 1
;openKeyboard.c,284 :: 		for (BMask=1; BMask<128; BMask<<=1){
$05DF	$3001			MOVLW	1
$05E0	$00CE			MOVWF	_BMask
$05E1	$	L_scanSend_38:
$05E1	$3080			MOVLW	128
$05E2	$1303			BCF	STATUS, RP1
$05E3	$1283			BCF	STATUS, RP0
$05E4	$024E			SUBWF	_BMask, 0
$05E5	$1803			BTFSC	STATUS, C
$05E6	$2E2F			GOTO	L_scanSend_39
;openKeyboard.c,285 :: 		if (someThingChanged & BMask)
$05E7	$084E			MOVF	_BMask, 0
$05E8	$054D			ANDWF	_somethingChanged, 0
$05E9	$00F0			MOVWF	STACK_0
$05EA	$1903			BTFSC	STATUS, Z
$05EB	$2E26			GOTO	L_scanSend_41
;openKeyboard.c,286 :: 		USART_Write(scanMap[idx] | (((data[sc]&BMask)>>bs)<<6)); // | 64 if pressed
$05EC	$085B			MOVF	scanSend_idx_L0, 0
$05ED	$3FA9			ADDLW	#_scanMap
$05EE	$00F0			MOVWF	STACK_0
$05EF	$3002			MOVLW	@#_scanMap
$05F0	$1803			BTFSC	STATUS, C
$05F1	$3F01			ADDLW	1
$05F2	$00F1			MOVWF	STACK_0+1
$05F3	$0870			MOVF	STACK_0, 0
$05F4	$00B5			MOVWF	___DoICPLoAddr
$05F5	$0871			MOVF	STACK_0+1, 0
$05F6	$00B4			MOVWF	___DoICPHiAddr
$05F7	$080A			MOVF	PCLATH, 0
$05F8	$00B3			MOVWF	___DoICPSavePCLATH
$05F9	$22DC			CALL	_____DoICP
$05FA	$00DE			MOVWF	FARG_Usart_Write+0
$05FB	$0833			MOVF	___DoICPSavePCLATH, 0
$05FC	$008A			MOVWF	PCLATH
$05FD	$085C			MOVF	scanSend_sc_L0, 0
$05FE	$3F3F			ADDLW	_data
$05FF	$0084			MOVWF	FSR
$0600	$0800			MOVF	INDF, 0
$0601	$00F0			MOVWF	STACK_0
$0602	$084E			MOVF	_BMask, 0
$0603	$0570			ANDWF	STACK_0, 0
$0604	$00F2			MOVWF	STACK_2
$0605	$085D			MOVF	scanSend_bs_L0, 0
$0606	$00F0			MOVWF	STACK_0
$0607	$0872			MOVF	STACK_2, 0
$0608	$00F3			MOVWF	STACK_3
$0609	$0870			MOVF	STACK_0, 0
$060A	$	L_scanSend_93:
$060A	$1903			BTFSC	STATUS, Z
$060B	$2E12			GOTO	L_scanSend_94
$060C	$1303			BCF	STATUS, RP1
$060D	$1283			BCF	STATUS, RP0
$060E	$0CF3			RRF	STACK_3, 1
$060F	$13F3			BCF	STACK_3, 7
$0610	$3FFF			ADDLW	255
$0611	$2E0A			GOTO	L_scanSend_93
$0612	$	L_scanSend_94:
$0612	$3006			MOVLW	6
$0613	$1303			BCF	STATUS, RP1
$0614	$1283			BCF	STATUS, RP0
$0615	$00F2			MOVWF	STACK_2
$0616	$0873			MOVF	STACK_3, 0
$0617	$00F0			MOVWF	STACK_0
$0618	$0872			MOVF	STACK_2, 0
$0619	$	L_scanSend_95:
$0619	$1903			BTFSC	STATUS, Z
$061A	$2E21			GOTO	L_scanSend_96
$061B	$1303			BCF	STATUS, RP1
$061C	$1283			BCF	STATUS, RP0
$061D	$0DF0			RLF	STACK_0, 1
$061E	$1070			BCF	STACK_0, 0
$061F	$3FFF			ADDLW	255
$0620	$2E19			GOTO	L_scanSend_95
$0621	$	L_scanSend_96:
$0621	$1303			BCF	STATUS, RP1
$0622	$1283			BCF	STATUS, RP0
$0623	$0870			MOVF	STACK_0, 0
$0624	$04DE			IORWF	FARG_Usart_Write+0, 1
$0625	$2298			CALL	_Usart_Write
$0626	$	L_scanSend_41:
;openKeyboard.c,287 :: 		bs++;
$0626	$1303			BCF	STATUS, RP1
$0627	$1283			BCF	STATUS, RP0
$0628	$0ADD			INCF	scanSend_bs_L0, 1
;openKeyboard.c,288 :: 		idx++;
$0629	$0ADB			INCF	scanSend_idx_L0, 1
;openKeyboard.c,289 :: 		}
$062A	$	L_scanSend_40:
;openKeyboard.c,284 :: 		for (BMask=1; BMask<128; BMask<<=1){
$062A	$1303			BCF	STATUS, RP1
$062B	$1283			BCF	STATUS, RP0
$062C	$0DCE			RLF	_BMask, 1
$062D	$104E			BCF	_BMask, 0
;openKeyboard.c,289 :: 		}
$062E	$2DE1			GOTO	L_scanSend_38
$062F	$	L_scanSend_39:
;openKeyboard.c,290 :: 		sc++;
$062F	$1303			BCF	STATUS, RP1
$0630	$1283			BCF	STATUS, RP0
$0631	$0ADC			INCF	scanSend_sc_L0, 1
;openKeyboard.c,291 :: 		}
$0632	$	L_scanSend_37:
;openKeyboard.c,281 :: 		for (AMask=1; AMask<128; AMask<<=1){
$0632	$1303			BCF	STATUS, RP1
$0633	$1283			BCF	STATUS, RP0
$0634	$0DB7			RLF	_AMask, 1
$0635	$1037			BCF	_AMask, 0
;openKeyboard.c,291 :: 		}
$0636	$2DCC			GOTO	L_scanSend_35
$0637	$	L_scanSend_36:
;openKeyboard.c,292 :: 		}
$0637	$0008			RETURN
$0638	$	_serialSend:
;openKeyboard.c,262 :: 		void serialSend(){
;openKeyboard.c,263 :: 		unsigned char idx = 0;
$0638	$1303			BCF	STATUS, RP1
$0639	$1283			BCF	STATUS, RP0
$063A	$01DB			CLRF	serialSend_idx_L0, 1
;openKeyboard.c,264 :: 		unsigned char sc = 0;
$063B	$01DC			CLRF	serialSend_sc_L0, 1
;openKeyboard.c,266 :: 		for (AMask=1; AMask<128; AMask<<=1){
$063C	$3001			MOVLW	1
$063D	$00B7			MOVWF	_AMask
$063E	$	L_serialSend_28:
$063E	$3080			MOVLW	128
$063F	$1303			BCF	STATUS, RP1
$0640	$1283			BCF	STATUS, RP0
$0641	$0237			SUBWF	_AMask, 0
$0642	$1803			BTFSC	STATUS, C
$0643	$2E82			GOTO	L_serialSend_29
;openKeyboard.c,267 :: 		for (BMask=1; BMask<128; BMask<<=1){
$0644	$3001			MOVLW	1
$0645	$00CE			MOVWF	_BMask
$0646	$	L_serialSend_31:
$0646	$3080			MOVLW	128
$0647	$1303			BCF	STATUS, RP1
$0648	$1283			BCF	STATUS, RP0
$0649	$024E			SUBWF	_BMask, 0
$064A	$1803			BTFSC	STATUS, C
$064B	$2E7A			GOTO	L_serialSend_32
;openKeyboard.c,268 :: 		if (justPressed[sc] & BMask) USART_Write(serialMap[alt][idx]);
$064C	$085C			MOVF	serialSend_sc_L0, 0
$064D	$3F46			ADDLW	_justPressed
$064E	$0084			MOVWF	FSR
$064F	$0800			MOVF	INDF, 0
$0650	$00F0			MOVWF	STACK_0
$0651	$084E			MOVF	_BMask, 0
$0652	$05F0			ANDWF	STACK_0, 1
$0653	$1903			BTFSC	STATUS, Z
$0654	$2E72			GOTO	L_serialSend_34
$0655	$084F			MOVF	_alt, 0
$0656	$00F0			MOVWF	STACK_0
$0657	$01F1			CLRF	STACK_0+1
$0658	$3031			MOVLW	49
$0659	$00F4			MOVWF	STACK_4
$065A	$3000			MOVLW	0
$065B	$00F5			MOVWF	STACK_4+1
$065C	$23A8			CALL	_mul_16x16_u
$065D	$30E3			MOVLW	#_serialMap
$065E	$07F0			ADDWF	STACK_0, 1
$065F	$3002			MOVLW	@#_serialMap
$0660	$1803			BTFSC	STATUS, C
$0661	$3F01			ADDLW	1
$0662	$07F1			ADDWF	STACK_0+1, 1
$0663	$085B			MOVF	serialSend_idx_L0, 0
$0664	$07F0			ADDWF	STACK_0, 1
$0665	$1803			BTFSC	STATUS, C
$0666	$0AF1			INCF	STACK_0+1, 1
$0667	$0870			MOVF	STACK_0, 0
$0668	$00B5			MOVWF	___DoICPLoAddr
$0669	$0871			MOVF	STACK_0+1, 0
$066A	$00B4			MOVWF	___DoICPHiAddr
$066B	$080A			MOVF	PCLATH, 0
$066C	$00B3			MOVWF	___DoICPSavePCLATH
$066D	$22DC			CALL	_____DoICP
$066E	$00DE			MOVWF	FARG_Usart_Write+0
$066F	$0833			MOVF	___DoICPSavePCLATH, 0
$0670	$008A			MOVWF	PCLATH
$0671	$2298			CALL	_Usart_Write
$0672	$	L_serialSend_34:
;openKeyboard.c,269 :: 		idx++;
$0672	$1303			BCF	STATUS, RP1
$0673	$1283			BCF	STATUS, RP0
$0674	$0ADB			INCF	serialSend_idx_L0, 1
;openKeyboard.c,270 :: 		}
$0675	$	L_serialSend_33:
;openKeyboard.c,267 :: 		for (BMask=1; BMask<128; BMask<<=1){
$0675	$1303			BCF	STATUS, RP1
$0676	$1283			BCF	STATUS, RP0
$0677	$0DCE			RLF	_BMask, 1
$0678	$104E			BCF	_BMask, 0
;openKeyboard.c,270 :: 		}
$0679	$2E46			GOTO	L_serialSend_31
$067A	$	L_serialSend_32:
;openKeyboard.c,271 :: 		sc++;
$067A	$1303			BCF	STATUS, RP1
$067B	$1283			BCF	STATUS, RP0
$067C	$0ADC			INCF	serialSend_sc_L0, 1
;openKeyboard.c,272 :: 		}
$067D	$	L_serialSend_30:
;openKeyboard.c,266 :: 		for (AMask=1; AMask<128; AMask<<=1){
$067D	$1303			BCF	STATUS, RP1
$067E	$1283			BCF	STATUS, RP0
$067F	$0DB7			RLF	_AMask, 1
$0680	$1037			BCF	_AMask, 0
;openKeyboard.c,272 :: 		}
$0681	$2E3E			GOTO	L_serialSend_28
$0682	$	L_serialSend_29:
;openKeyboard.c,273 :: 		alt = alts[data[2]&1|((data[1]&1)<<1)|((data[0]&64)>>4)]; // next scan can use alt retrieved here
$0682	$3001			MOVLW	1
$0683	$1303			BCF	STATUS, RP1
$0684	$1283			BCF	STATUS, RP0
$0685	$0541			ANDWF	_data+2, 0
$0686	$00F4			MOVWF	STACK_4
$0687	$3001			MOVLW	1
$0688	$0540			ANDWF	_data+1, 0
$0689	$00F3			MOVWF	STACK_3
$068A	$0873			MOVF	STACK_3, 0
$068B	$00F0			MOVWF	STACK_0
$068C	$01F1			CLRF	STACK_0+1
$068D	$0DF0			RLF	STACK_0, 1
$068E	$0DF1			RLF	STACK_0+1, 1
$068F	$1070			BCF	STACK_0, 0
$0690	$3000			MOVLW	0
$0691	$00F5			MOVWF	STACK_4+1
$0692	$0870			MOVF	STACK_0, 0
$0693	$04F4			IORWF	STACK_4, 1
$0694	$0871			MOVF	STACK_0+1, 0
$0695	$04F5			IORWF	STACK_4+1, 1
$0696	$3040			MOVLW	64
$0697	$053F			ANDWF	_data, 0
$0698	$00F3			MOVWF	STACK_3
$0699	$0873			MOVF	STACK_3, 0
$069A	$00F0			MOVWF	STACK_0
$069B	$0CF0			RRF	STACK_0, 1
$069C	$13F0			BCF	STACK_0, 7
$069D	$0CF0			RRF	STACK_0, 1
$069E	$13F0			BCF	STACK_0, 7
$069F	$0CF0			RRF	STACK_0, 1
$06A0	$13F0			BCF	STACK_0, 7
$06A1	$0CF0			RRF	STACK_0, 1
$06A2	$13F0			BCF	STACK_0, 7
$06A3	$3000			MOVLW	0
$06A4	$00F1			MOVWF	STACK_0+1
$06A5	$0874			MOVF	STACK_4, 0
$06A6	$04F0			IORWF	STACK_0, 1
$06A7	$0875			MOVF	STACK_4+1, 0
$06A8	$04F1			IORWF	STACK_0+1, 1
$06A9	$0870			MOVF	STACK_0, 0
$06AA	$3F50			ADDLW	_alts
$06AB	$0084			MOVWF	FSR
$06AC	$0800			MOVF	INDF, 0
$06AD	$00CF			MOVWF	_alt
;openKeyboard.c,274 :: 		}
$06AE	$0008			RETURN
$06AF	$	_Delay_80us:
;delays.c,23 :: 		void Delay_80us() {
;delays.c,24 :: 		Delay_us(78);
$06AF	$3019			MOVLW	25
$06B0	$1303			BCF	STATUS, RP1
$06B1	$1283			BCF	STATUS, RP0
$06B2	$00FA			MOVWF	STACK_10
$06B3	$0BFA			DECFSZ	STACK_10, F
$06B4	$2EB3			GOTO	$-1
$06B5	$0000			NOP
$06B6	$0000			NOP
;delays.c,25 :: 		}
$06B7	$0008			RETURN
$0800	$	GlobalIniopenKeyboard:
$0800	$3000			MOVLW	0
$0801	$1303			BCF	STATUS, RP1
$0802	$1283			BCF	STATUS, RP0
$0803	$00BF			MOVWF	_data+0
$0804	$3000			MOVLW	0
$0805	$00C0			MOVWF	_data+1
$0806	$3000			MOVLW	0
$0807	$00C1			MOVWF	_data+2
$0808	$3000			MOVLW	0
$0809	$00C2			MOVWF	_data+3
$080A	$3000			MOVLW	0
$080B	$00C3			MOVWF	_data+4
$080C	$3000			MOVLW	0
$080D	$00C4			MOVWF	_data+5
$080E	$3000			MOVLW	0
$080F	$00C5			MOVWF	_data+6
$0810	$3000			MOVLW	0
$0811	$00B8			MOVWF	_oldData+0
$0812	$3000			MOVLW	0
$0813	$00B9			MOVWF	_oldData+1
$0814	$3000			MOVLW	0
$0815	$00BA			MOVWF	_oldData+2
$0816	$3000			MOVLW	0
$0817	$00BB			MOVWF	_oldData+3
$0818	$3000			MOVLW	0
$0819	$00BC			MOVWF	_oldData+4
$081A	$3000			MOVLW	0
$081B	$00BD			MOVWF	_oldData+5
$081C	$3000			MOVLW	0
$081D	$00BE			MOVWF	_oldData+6
$081E	$3000			MOVLW	0
$081F	$00C6			MOVWF	_justPressed+0
$0820	$3000			MOVLW	0
$0821	$00C7			MOVWF	_justPressed+1
$0822	$3000			MOVLW	0
$0823	$00C8			MOVWF	_justPressed+2
$0824	$3000			MOVLW	0
$0825	$00C9			MOVWF	_justPressed+3
$0826	$3000			MOVLW	0
$0827	$00CA			MOVWF	_justPressed+4
$0828	$3000			MOVLW	0
$0829	$00CB			MOVWF	_justPressed+5
$082A	$3000			MOVLW	0
$082B	$00CC			MOVWF	_justPressed+6
$082C	$3000			MOVLW	0
$082D	$00B6			MOVWF	_newlyPressd+0
$082E	$3000			MOVLW	0
$082F	$00B7			MOVWF	_AMask+0
$0830	$3000			MOVLW	0
$0831	$00CE			MOVWF	_BMask+0
$0832	$3000			MOVLW	0
$0833	$00CD			MOVWF	_somethingChanged+0
$0834	$30FF			MOVLW	255
$0835	$00A0			MOVWF	_timer+0
$0836	$30FF			MOVLW	255
$0837	$00A1			MOVWF	_timer+1
$0838	$3000			MOVLW	0
$0839	$00A2			MOVWF	_timer+2
$083A	$3000			MOVLW	0
$083B	$00A3			MOVWF	_timer+3
$083C	$3000			MOVLW	0
$083D	$00A4			MOVWF	_lightFadeOffTime+0
$083E	$3080			MOVLW	128
$083F	$00A5			MOVWF	_lightFadeOffTime+1
$0840	$3000			MOVLW	0
$0841	$00A6			MOVWF	_lightFadeOffTime+2
$0842	$3000			MOVLW	0
$0843	$00A7			MOVWF	_lightFadeOffTime+3
$0844	$3000			MOVLW	0
$0845	$00D0			MOVWF	_alts+0
$0846	$3001			MOVLW	1
$0847	$00D1			MOVWF	_alts+1
$0848	$3002			MOVLW	2
$0849	$00D2			MOVWF	_alts+2
$084A	$3002			MOVLW	2
$084B	$00D3			MOVWF	_alts+3
$084C	$3003			MOVLW	3
$084D	$00D4			MOVWF	_alts+4
$084E	$3003			MOVLW	3
$084F	$00D5			MOVWF	_alts+5
$0850	$3003			MOVLW	3
$0851	$00D6			MOVWF	_alts+6
$0852	$3003			MOVLW	3
$0853	$00D7			MOVWF	_alts+7
$0854	$3000			MOVLW	0
$0855	$00AF			MOVWF	_send+0
$0856	$3000			MOVLW	0
$0857	$00B0			MOVWF	_send+1
$0858	$3000			MOVLW	0
$0859	$00B1			MOVWF	_send+2
$085A	$3000			MOVLW	0
$085B	$00AA			MOVWF	_lightHandler+0
$085C	$3000			MOVLW	0
$085D	$00AB			MOVWF	_lightHandler+1
$085E	$3000			MOVLW	0
$085F	$00AC			MOVWF	_lightHandler+2
$0860	$3000			MOVLW	0
$0861	$00AE			MOVWF	_baudrate+0
$0862	$3000			MOVLW	0
$0863	$00B2			MOVWF	_sendMode+0
$0864	$3000			MOVLW	0
$0865	$00AD			MOVWF	_lightMode+0
$0866	$3000			MOVLW	0
$0867	$00A9			MOVWF	_lightStrenght+0
$0868	$3000			MOVLW	0
$0869	$00A8			MOVWF	_pwmRunning+0
;openKeyboard.c,517 :: 		}
$086A	$0008			RETURN
$06B8	$	_____DoICF:
$06B8	$1303			BCF	STATUS, RP1
$06B9	$1283			BCF	STATUS, RP0
$06BA	$0834			MOVF	___DoICPHiAddr, 0
$06BB	$008A			MOVWF	PCLATH
$06BC	$0835			MOVF	___DoICPLoAddr, 0
$06BD	$0082			MOVWF	PCL
$06BE	$0008			RETURN
$086B	$	_main:
;openKeyboard.c,453 :: 		void main() {
;openKeyboard.c,455 :: 		OSCCON = 0x67;                    // 01100111 - 0110 stands for 4Mhz internal clock
$086B	$2000			CALL	GlobalIniopenKeyboard
$086C	$3067			MOVLW	103
$086D	$1303			BCF	STATUS, RP1
$086E	$1683			BSF	STATUS, RP0
$086F	$008F			MOVWF	OSCCON
;openKeyboard.c,457 :: 		ANSEL  = 0;                       // Configure AN pins as digital I/O
$0870	$1703			BSF	STATUS, RP1
$0871	$0188			CLRF	ANSEL, 1
;openKeyboard.c,458 :: 		ANSELH = 0;
$0872	$0189			CLRF	ANSELH, 1
;openKeyboard.c,460 :: 		PORTA  = 0;                       // init port A
$0873	$1303			BCF	STATUS, RP1
$0874	$1283			BCF	STATUS, RP0
$0875	$0185			CLRF	PORTA, 1
;openKeyboard.c,461 :: 		TRISA  = 0;                       // 1 = input
$0876	$1683			BSF	STATUS, RP0
$0877	$0185			CLRF	TRISA, 1
;openKeyboard.c,463 :: 		PORTB       = 0;                  // initialize PORTB
$0878	$1283			BCF	STATUS, RP0
$0879	$0186			CLRF	PORTB, 1
;openKeyboard.c,464 :: 		TRISB       = 255;                // designate PORTB as all input
$087A	$30FF			MOVLW	255
$087B	$1683			BSF	STATUS, RP0
$087C	$0086			MOVWF	TRISB
;openKeyboard.c,466 :: 		PORTC       = 0;                // initialize PORTC
$087D	$1283			BCF	STATUS, RP0
$087E	$0187			CLRF	PORTC, 1
;openKeyboard.c,467 :: 		TRISC       = 0;                // designate PORTB 0-7 as output
$087F	$1683			BSF	STATUS, RP0
$0880	$0187			CLRF	TRISC, 1
;openKeyboard.c,469 :: 		OPTION_REG  = 0;                  // pull-ups enabled on PORTB....no external pull-downs
$0881	$0181			CLRF	OPTION_REG, 1
;openKeyboard.c,474 :: 		INTCON.RBIE = 0; // disables PORTB on-change interrupt
$0882	$118B			BCF	INTCON, 3
;openKeyboard.c,475 :: 		INTCON.RBIF = 0; // clear PORTB mismatch values
$0883	$100B			BCF	INTCON, 0
;openKeyboard.c,477 :: 		IOCB = 127; // pin 0-6 of PORTB configured to raise interrupt when changed
$0884	$307F			MOVLW	127
$0885	$0096			MOVWF	IOCB
;openKeyboard.c,479 :: 		PIE1 = 32; // RCIE = 1; enables EUSART on-receive interrupt
$0886	$3020			MOVLW	32
$0887	$008C			MOVWF	PIE1
;openKeyboard.c,481 :: 		INTCON.GIE = 1; // Global Interrupt Enable/disable
$0888	$178B			BSF	INTCON, 7
;openKeyboard.c,484 :: 		Delay_ms(20);    // required for eeprom_read to work correctly
$0889	$301A			MOVLW	26
$088A	$00FB			MOVWF	STACK_11
$088B	$30FF			MOVLW	255
$088C	$00FA			MOVWF	STACK_10
$088D	$0BFB			DECFSZ	STACK_11, F
$088E	$2890			GOTO	$+2
$088F	$2893			GOTO	$+4
$0890	$0BFA			DECFSZ	STACK_10, F
$0891	$2890			GOTO	$-1
$0892	$288D			GOTO	$-5
$0893	$30E7			MOVLW	231
$0894	$00FA			MOVWF	STACK_10
$0895	$0BFA			DECFSZ	STACK_10, F
$0896	$2895			GOTO	$-1
$0897	$0000			NOP
;openKeyboard.c,485 :: 		sendMode = EEprom_read(CONFIG_SENDMODE);
$0898	$3002			MOVLW	2
$0899	$1283			BCF	STATUS, RP0
$089A	$00DB			MOVWF	FARG_EEprom_read+0
$089B	$118A			BCF	PCLATH, 3
$089C	$23D3			CALL	_EEprom_read
$089D	$158A			BSF	PCLATH, 3
$089E	$0870			MOVF	STACK_0, 0
$089F	$1303			BCF	STATUS, RP1
$08A0	$00B2			MOVWF	_sendMode
;openKeyboard.c,486 :: 		setupSendMode(sendMode);
$08A1	$0870			MOVF	STACK_0, 0
$08A2	$00DE			MOVWF	FARG_setupSendMode+0
$08A3	$118A			BCF	PCLATH, 3
$08A4	$2248			CALL	_setupSendMode
$08A5	$158A			BSF	PCLATH, 3
;openKeyboard.c,490 :: 		Delay_ms(20);    // required for eeprom_read to work correctly
$08A6	$301A			MOVLW	26
$08A7	$00FB			MOVWF	STACK_11
$08A8	$30FF			MOVLW	255
$08A9	$00FA			MOVWF	STACK_10
$08AA	$0BFB			DECFSZ	STACK_11, F
$08AB	$28AD			GOTO	$+2
$08AC	$28B0			GOTO	$+4
$08AD	$0BFA			DECFSZ	STACK_10, F
$08AE	$28AD			GOTO	$-1
$08AF	$28AA			GOTO	$-5
$08B0	$30E7			MOVLW	231
$08B1	$00FA			MOVWF	STACK_10
$08B2	$0BFA			DECFSZ	STACK_10, F
$08B3	$28B2			GOTO	$-1
$08B4	$0000			NOP
;openKeyboard.c,491 :: 		baudrate = EEprom_read(CONFIG_BAUDRATE);
$08B5	$3001			MOVLW	1
$08B6	$00DB			MOVWF	FARG_EEprom_read+0
$08B7	$118A			BCF	PCLATH, 3
$08B8	$23D3			CALL	_EEprom_read
$08B9	$158A			BSF	PCLATH, 3
$08BA	$0870			MOVF	STACK_0, 0
$08BB	$1303			BCF	STATUS, RP1
$08BC	$00AE			MOVWF	_baudrate
;openKeyboard.c,492 :: 		setupUsart(baudrate); // Initalize USART (xxxx baud rate, 1 stop bit, no parity...)
$08BD	$0870			MOVF	STACK_0, 0
$08BE	$00DE			MOVWF	FARG_setupUsart+0
$08BF	$118A			BCF	PCLATH, 3
$08C0	$21C7			CALL	_setupUsart
$08C1	$158A			BSF	PCLATH, 3
;openKeyboard.c,495 :: 		Delay_ms(20);    // required for eeprom_read to work correctly
$08C2	$301A			MOVLW	26
$08C3	$00FB			MOVWF	STACK_11
$08C4	$30FF			MOVLW	255
$08C5	$00FA			MOVWF	STACK_10
$08C6	$0BFB			DECFSZ	STACK_11, F
$08C7	$28C9			GOTO	$+2
$08C8	$28CC			GOTO	$+4
$08C9	$0BFA			DECFSZ	STACK_10, F
$08CA	$28C9			GOTO	$-1
$08CB	$28C6			GOTO	$-5
$08CC	$30E7			MOVLW	231
$08CD	$00FA			MOVWF	STACK_10
$08CE	$0BFA			DECFSZ	STACK_10, F
$08CF	$28CE			GOTO	$-1
$08D0	$0000			NOP
;openKeyboard.c,496 :: 		lightFadeOffTime = EEprom_read(CONFIG_LIGHTFADEOFFTIME) << 8;
$08D1	$3005			MOVLW	5
$08D2	$00DB			MOVWF	FARG_EEprom_read+0
$08D3	$118A			BCF	PCLATH, 3
$08D4	$23D3			CALL	_EEprom_read
$08D5	$158A			BSF	PCLATH, 3
$08D6	$3008			MOVLW	8
$08D7	$00F1			MOVWF	STACK_1
$08D8	$0870			MOVF	STACK_0, 0
$08D9	$1303			BCF	STATUS, RP1
$08DA	$00A4			MOVWF	_lightFadeOffTime
$08DB	$01A5			CLRF	_lightFadeOffTime+1
$08DC	$0871			MOVF	STACK_1, 0
$08DD	$	L_main_97:
$08DD	$1903			BTFSC	STATUS, Z
$08DE	$28E6			GOTO	L_main_98
$08DF	$1303			BCF	STATUS, RP1
$08E0	$1283			BCF	STATUS, RP0
$08E1	$0DA4			RLF	_lightFadeOffTime, 1
$08E2	$0DA5			RLF	_lightFadeOffTime+1, 1
$08E3	$1024			BCF	_lightFadeOffTime, 0
$08E4	$3FFF			ADDLW	255
$08E5	$28DD			GOTO	L_main_97
$08E6	$	L_main_98:
$08E6	$3000			MOVLW	0
$08E7	$1303			BCF	STATUS, RP1
$08E8	$1283			BCF	STATUS, RP0
$08E9	$00A6			MOVWF	_lightFadeOffTime+2
$08EA	$00A7			MOVWF	_lightFadeOffTime+3
;openKeyboard.c,497 :: 		lightStrenght = EEprom_read(CONFIG_LIGHTSTRENGTH);
$08EB	$3004			MOVLW	4
$08EC	$00DB			MOVWF	FARG_EEprom_read+0
$08ED	$118A			BCF	PCLATH, 3
$08EE	$23D3			CALL	_EEprom_read
$08EF	$158A			BSF	PCLATH, 3
$08F0	$0870			MOVF	STACK_0, 0
$08F1	$1303			BCF	STATUS, RP1
$08F2	$00A9			MOVWF	_lightStrenght
;openKeyboard.c,499 :: 		Delay_ms(20);    // required for eeprom_read to work correctly
$08F3	$301A			MOVLW	26
$08F4	$00FB			MOVWF	STACK_11
$08F5	$30FF			MOVLW	255
$08F6	$00FA			MOVWF	STACK_10
$08F7	$0BFB			DECFSZ	STACK_11, F
$08F8	$28FA			GOTO	$+2
$08F9	$28FD			GOTO	$+4
$08FA	$0BFA			DECFSZ	STACK_10, F
$08FB	$28FA			GOTO	$-1
$08FC	$28F7			GOTO	$-5
$08FD	$30E7			MOVLW	231
$08FE	$00FA			MOVWF	STACK_10
$08FF	$0BFA			DECFSZ	STACK_10, F
$0900	$28FF			GOTO	$-1
$0901	$0000			NOP
;openKeyboard.c,500 :: 		lightMode = EEprom_read(CONFIG_LIGHTMODE);
$0902	$3003			MOVLW	3
$0903	$00DB			MOVWF	FARG_EEprom_read+0
$0904	$118A			BCF	PCLATH, 3
$0905	$23D3			CALL	_EEprom_read
$0906	$158A			BSF	PCLATH, 3
$0907	$0870			MOVF	STACK_0, 0
$0908	$1303			BCF	STATUS, RP1
$0909	$00AD			MOVWF	_lightMode
;openKeyboard.c,501 :: 		setUpLightMode(lightMode);
$090A	$0870			MOVF	STACK_0, 0
$090B	$00DE			MOVWF	FARG_setupLightMode+0
$090C	$118A			BCF	PCLATH, 3
$090D	$2159			CALL	_setupLightMode
$090E	$158A			BSF	PCLATH, 3
;openKeyboard.c,503 :: 		do {
$090F	$	L_main_86:
;openKeyboard.c,505 :: 		doScan();
$090F	$118A			BCF	PCLATH, 3
$0910	$23DF			CALL	_doScan
$0911	$158A			BSF	PCLATH, 3
;openKeyboard.c,507 :: 		if (data[1]&2) {
$0912	$1303			BCF	STATUS, RP1
$0913	$1283			BCF	STATUS, RP0
$0914	$1CC0			BTFSS	_data+1, 1
$0915	$291A			GOTO	L_main_88
;openKeyboard.c,508 :: 		config();  // people button pressed -> config mode
$0916	$118A			BCF	PCLATH, 3
$0917	$2448			CALL	_config
$0918	$158A			BSF	PCLATH, 3
;openKeyboard.c,509 :: 		}else{
$0919	$2930			GOTO	L_main_89
$091A	$	L_main_88:
;openKeyboard.c,510 :: 		if (oldData[1]&2) saveConfig(); // ppl btn just released... save config
$091A	$1303			BCF	STATUS, RP1
$091B	$1283			BCF	STATUS, RP0
$091C	$1CB9			BTFSS	_oldData+1, 1
$091D	$2921			GOTO	L_main_90
$091E	$118A			BCF	PCLATH, 3
$091F	$2552			CALL	_saveConfig
$0920	$158A			BSF	PCLATH, 3
$0921	$	L_main_90:
;openKeyboard.c,511 :: 		send();
$0921	$1303			BCF	STATUS, RP1
$0922	$1283			BCF	STATUS, RP0
$0923	$082F			MOVF	_send, 0
$0924	$00B5			MOVWF	___DoICPLoAddr
$0925	$0830			MOVF	_send+1, 0
$0926	$00B4			MOVWF	___DoICPHiAddr
$0927	$080A			MOVF	PCLATH, 0
$0928	$00B3			MOVWF	___DoICPSavePCLATH
$0929	$118A			BCF	PCLATH, 3
$092A	$26B8			CALL	_____DoICF
$092B	$158A			BSF	PCLATH, 3
$092C	$1303			BCF	STATUS, RP1
$092D	$1283			BCF	STATUS, RP0
$092E	$0833			MOVF	___DoICPSavePCLATH, 0
$092F	$008A			MOVWF	PCLATH
;openKeyboard.c,512 :: 		}
$0930	$	L_main_89:
;openKeyboard.c,513 :: 		lightHandler();
$0930	$1303			BCF	STATUS, RP1
$0931	$1283			BCF	STATUS, RP0
$0932	$082A			MOVF	_lightHandler, 0
$0933	$00B5			MOVWF	___DoICPLoAddr
$0934	$082B			MOVF	_lightHandler+1, 0
$0935	$00B4			MOVWF	___DoICPHiAddr
$0936	$080A			MOVF	PCLATH, 0
$0937	$00B3			MOVWF	___DoICPSavePCLATH
$0938	$118A			BCF	PCLATH, 3
$0939	$26B8			CALL	_____DoICF
$093A	$158A			BSF	PCLATH, 3
$093B	$1303			BCF	STATUS, RP1
$093C	$1283			BCF	STATUS, RP0
$093D	$0833			MOVF	___DoICPSavePCLATH, 0
$093E	$008A			MOVWF	PCLATH
;openKeyboard.c,514 :: 		Delay_80us(); // without this delay, pic hangs on sleep...
$093F	$118A			BCF	PCLATH, 3
$0940	$26AF			CALL	_Delay_80us
$0941	$158A			BSF	PCLATH, 3
;openKeyboard.c,515 :: 		} while (1);                   // endless loop
$0942	$290F			GOTO	L_main_86
;openKeyboard.c,517 :: 		}
$0943	$2943			GOTO	$
